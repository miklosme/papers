{
  "arxivId": "2410.11782",
  "title": "G-Designer: Architecting Multi-agent Communication Topologies via Graph Neural Networks",
  "abstract": "Recent advancements in large language model (LLM)-based agents have demonstrated that collective intelligence can significantly surpass the capabilities of individual agents, primarily due to well-crafted inter-agent communication topologies. Despite the diverse and high-performing designs available, practitioners often face confusion when selecting the most effective pipeline for their specific task: Which topology is the best choice for my task, avoiding unnecessary communication token overhead while ensuring high-quality solution? In response to this dilemma, we introduce G-Designer, an adaptive, efficient, and robust solution for multi-agent deployment, which dynamically designs task-aware, customized communication topologies. Specifically, G-Designer models the multi-agent system as a multi-agent network, leveraging a variational graph auto-encoder to encode both the nodes (agents) and a task-specific virtual node, and decodes a task-adaptive and high-performing communication topology. Extensive experiments on six benchmarks showcase that G-Designer is: (1) high-performing, achieving superior results on MMLU with accuracy at 84.50% and on HumanEval with pass@1 at 89.90%; (2) task-adaptive, architecting communication protocols tailored to task difficulty, reducing token consumption by up to 95.33% on HumanEval; and (3) adversarially robust, defending against agent adversarial attacks with merely 0.3% accuracy drop. The code is anonymously available at https://anonymous.4open.science/r/GDesigner-3063.",
  "summary": "This paper introduces G-Designer, an AI system that automatically designs the best communication structure for teams of AI agents working on a given task. This addresses the challenge of finding the optimal way for AI agents to collaborate, which significantly impacts their collective intelligence.\n\nKey points for LLM-based multi-agent systems:\n\n* **Task-adaptive communication:** G-Designer tailors the communication structure to the specific task, leading to more efficient and effective collaboration.\n* **Reduced token consumption:** By simplifying communication for simpler tasks, G-Designer minimizes unnecessary overhead and computational cost, a major concern for LLM-based systems.\n* **Robustness to adversarial attacks:** The system can identify and mitigate the impact of malicious inputs, making multi-agent systems more reliable.",
  "takeaways": "This paper introduces G-Designer, a system for dynamically generating the communication structure of multi-agent LLM applications. Here's how a JavaScript developer can apply these insights:\n\n**Scenario:** Building a collaborative code generation tool\n\n**Problem:** Static communication structures (like chain or tree) might not be optimal for all coding tasks. G-Designer offers a way to dynamically adapt the communication flow based on task complexity.\n\n**Practical Application:**\n\n1. **Agent Representation (Node Encoder):**\n\n   * Use a JavaScript library like TensorFlow.js to implement a simple text embedding model (e.g., SentenceBERT).\n   * Each agent (e.g., Code Generator, Documenter, Tester) is represented by:\n      * `base`: The underlying LLM (e.g., \"gpt-4\").\n      * `role`: Agent's function (e.g., \"Code Generator\").\n      * `plugins`: Available tools (e.g., \"JavaScript compiler\", \"Jest testing framework\").\n   * Embed this information using the Node Encoder:\n\n     ```javascript\n     import * as tf from '@tensorflow/tfjs';\n     import * as sentenceBert from 'sentence-bert-js'; \n\n     const nodeEncoder = async (base, role, plugins) => {\n       const model = await sentenceBert.load();\n       const embeddings = await model.embed([base, role, plugins.join(' ')]); \n       return embeddings; \n     };\n     ```\n\n2. **Task-Specific Information:**\n\n   * Embed the user's coding request (the \"query\") similarly using the Node Encoder. This becomes the `taskNode`.\n\n3. **Anchor Topology:**\n\n   * Define a basic communication structure. For a simple code generation task, a chain could suffice:\n     ```javascript\n     const anchorTopology = [\n       [0, 1, 0], // Manager -> Programmer\n       [0, 0, 1], // Programmer -> Code Reviewer\n       [0, 0, 0]  // Code Reviewer\n     ];\n     ```\n\n4. **Graph Auto-encoder (Dynamic Topology Generation):**\n\n   * This part is more complex, involving training a graph neural network. You can explore libraries like:\n      * **TensorFlow.js:** For implementing the graph auto-encoder structure.\n      * **Deep Graph Library (DGL):** A powerful Python library, potentially usable with JavaScript bindings.\n   * Train this network on various coding requests and their ideal communication patterns (if available as labeled data). The output will be a dynamically generated adjacency matrix representing the communication topology.\n\n5. **Agent Interaction:**\n\n   * Implement a message-passing system where agents communicate based on the generated topology. This can be done using:\n      * **WebSockets:** For real-time, bidirectional communication.\n      * **Message queues (e.g., RabbitMQ):** For asynchronous communication.\n\n**JavaScript Libraries to Consider:**\n\n* **TensorFlow.js:** For machine learning tasks (embedding, graph auto-encoder).\n* **Socket.IO:** Simplifies WebSocket implementation.\n* **Amqplib:** For interacting with RabbitMQ (if using message queues).\n\n**Additional Notes:**\n\n* G-Designer's strength lies in its adaptability and potential for optimizing resource usage. It might be an overkill for simple applications where a fixed structure suffices.\n* This paper focuses on the high-level design. Implementing the full G-Designer architecture in JavaScript would be a significant undertaking, requiring expertise in graph neural networks and multi-agent system development. \n* Start with simpler aspects like dynamic agent profiling and explore more advanced concepts as your project evolves.\n\nBy incorporating these ideas, JavaScript developers can build more flexible and efficient LLM-powered applications that adapt their communication flow based on the task at hand.",
  "pseudocode": "```javascript\n// Algorithm 1: Designing workflow of G-Designer\n\nasync function designWithGDesigner(query, graphAutoencoder, learningRate) {\n  // Initialization for optimization loop\n  for (let queryIndex = 0; queryIndex < optimizationQueries.length; queryIndex++) {\n\n    // Step 1 & 2: Establish multi-agent network\n    const agentEmbeddings = [];\n    for (let agentIndex = 0; agentIndex < numAgents; agentIndex++) {\n      const agentFeatures = await nodeEncoder(\n        extractText(agents[agentIndex].base), \n        agents[agentIndex].role, \n        extractText(agents[agentIndex].plugins)\n      );\n      agentEmbeddings.push(agentFeatures);\n    }\n    const taskNodeEmbedding = await nodeEncoder(optimizationQueries[queryIndex]);\n\n    // Step 3: Set an anchor topology \n    const anchorTopology = createChainTopology(numAgents); // Example: chain structure\n\n    // Step 4: Construct task-specific multi-agent network\n    const multiAgentNetwork  = {\n      nodes: [...agentEmbeddings, taskNodeEmbedding], \n      edges: addTaskNodeEdges(anchorTopology) \n    };\n\n    // Step 5 & 6: Design communication topology\n    const latentAgentRepresentations = graphAutoencoder.encode(\n      multiAgentNetwork.nodes, \n      multiAgentNetwork.edges\n    );\n    const sketchedGraph = graphAutoencoder.decode(latentAgentRepresentations);\n    const communicationGraph = refineGraph(sketchedGraph, multiAgentNetwork.edges);\n\n    // Step 7: Guide multi-agent system collaboration (This is a simplified example)\n    let aggregatedSolution; \n    for (let round = 0; round < numDialogueRounds; round++) {\n      const agentResponses = [];\n      for (const agentIndex of communicationGraph.executionOrder(round)) { \n        const agentPrompt = constructPrompt(query, agentResponses, agents[agentIndex]);\n        const agentResponse = await agents[agentIndex].generate(agentPrompt);\n        agentResponses.push(agentResponse);\n      }\n      aggregatedSolution = aggregateResponses(agentResponses); \n    }\n\n    // Step 8: Update G-Designer parameters (using gradient descent - illustrative)\n    const loss = calculateLoss(aggregatedSolution, ...); \n    const gradients = calculateGradients(loss, ...);\n    graphAutoencoder.updateParameters(gradients, learningRate); \n  }\n\n  return graphAutoencoder; \n}\n\n// Placeholder functions - these would need actual implementations\nfunction extractText(data) { /* ... */ } \nfunction nodeEncoder(text) { /* ... */ }\nfunction createChainTopology(numNodes) { /* ... */ }\nfunction addTaskNodeEdges(topology) { /* ... */ } \nfunction refineGraph(graph, originalEdges) { /* ... */ }\nfunction constructPrompt(query, previousResponses, agent) { /* ... */ }\nfunction aggregateResponses(responses) { /* ... */ } \nfunction calculateLoss(solution, ...) { /* ... }\nfunction calculateGradients(loss, ...) { /* ... */ }\n```\n\n**Explanation:**\n\nThe JavaScript code implements the G-Designer algorithm for architecting multi-agent communication topologies. Let's break down the algorithm and its purpose:\n\n1. **Initialization (Lines 1-8):**\n   - The algorithm takes a `query`, a `graphAutoencoder` (which has encode and decode methods for a variational graph autoencoder), and a `learningRate` as input.\n   - It iterates through a set of `optimizationQueries` to learn a good communication topology.\n   - For each query, it initializes an empty list to store agent embeddings.\n\n2. **Establish Multi-agent Network (Lines 9-12):**\n   - It iterates through each agent and uses a `nodeEncoder` function to generate an embedding representation of the agent's base (LLM), role, and plugins.\n   - A `taskNodeEmbedding` is created based on the current `query` to provide task-specific context.\n   - An `anchorTopology` (e.g., a chain structure) is set as a starting point for the topology design.\n   - A `multiAgentNetwork` is created, containing all agent embeddings, the task node embedding, and the initial anchor topology.\n\n3. **Design Communication Topology (Lines 13-18):**\n   - The `graphAutoencoder` encodes the multi-agent network into `latentAgentRepresentations`.\n   - It decodes these representations in two phases:\n     - **Phase 1:** Generates a `sketchedGraph` representing a dense communication structure.\n     - **Phase 2:** Refines the `sketchedGraph` into a sparser, more informative `communicationGraph` based on sparsity constraints and the original anchor topology.\n\n4. **Guide Multi-agent System Collaboration (Lines 19-23):**\n   - The algorithm simulates multi-agent collaboration using the designed `communicationGraph`.\n   - For each round of interaction:\n     - It determines the execution order of agents based on the topology.\n     - It constructs a prompt for each agent, incorporating the query and previous responses.\n     - Each agent generates a response using its LLM (`generate` function).\n     - Agent responses are aggregated into a solution (`aggregateResponses` function).\n\n5. **Update G-Designer Parameters (Lines 24-25):**\n   - The algorithm calculates a `loss` function based on the quality of the aggregated solution.\n   - It computes gradients of the loss with respect to the `graphAutoencoder` parameters.\n   - It updates the `graphAutoencoder` parameters using gradient descent to minimize the loss and improve the topology design in subsequent iterations.\n\n**Purpose:**\n\nThe G-Designer algorithm aims to automate the design of effective and efficient communication topologies for multi-agent systems powered by Large Language Models (LLMs). By leveraging a variational graph autoencoder and incorporating task-specific information, G-Designer creates dynamic topologies that adapt to the complexity of the task, potentially reducing communication overhead and improving overall performance.",
  "simpleQuestion": "How to design optimal communication for LLM agents?",
  "timestamp": "2024-10-16T05:01:43.549Z"
}