{
  "arxivId": "2412.14570",
  "title": "Characterising Simulation-Based Program Equilibria",
  "abstract": "In Tennenholtz's program equilibrium, players of a game submit programs to play on their behalf. Each program receives the other programs' source code and outputs an action. This can model interactions involving AI agents, mutually transparent institutions, or commitments. Tennenholtz (2004) proves a folk theorem for program games, but the equilibria constructed are very brittle. We therefore consider simulation-based programs – i.e., programs that work by running opponents' programs. These are relatively robust (in particular, two programs that act the same are treated the same) and are more practical than proof-based approaches. Oesterheld's (2019) eGrounded Bot is such an approach. Unfortunately, it is not generally applicable to games of three or more players, and only allows for a limited range of equilibria in two-player games. In this paper, we propose a generalization to Oesterheld's (2019) eGrounded Bot. We prove a folk theorem for our programs in a setting with access to a shared source of randomness. We then characterize their equilibria in a setting without shared randomness. Both with and without shared randomness, we achieve a much wider range of equilibria than Oesterheld's (2019) eGrounded Bot. Finally, we explore the limits of simulation-based program equilibrium, showing that the Tennenholtz folk theorem cannot be attained by simulation-based programs without access to shared randomness.",
  "summary": "This paper explores how AI agents can interact strategically when they can see each other's code (\"program equilibrium\").  It proposes a new type of AI agent, a generalized \"epsilon-Grounded Bot,\" which is more robust and versatile than previous approaches. These bots simulate interactions in a simplified repeated game-like manner to choose actions.\n\nFor LLM-based multi-agent systems, this work offers insights into designing robust agent interactions even when LLMs have access to each other's prompts (analogous to code). The \"epsilon-Grounded Bot\" approach provides a more practical method for achieving cooperation in such scenarios compared to brittle methods relying on exact prompt comparison. It also shows that without shared randomness, full cooperation may be difficult to attain, which is a relevant constraint for many decentralized web applications.  The work introduces the concept of \"screening,\" analogous to parts of an LLM prompt being hidden from other LLMs, and explores how this impacts attainable equilibria, which is directly relevant to prompt engineering practices in multi-agent LLM scenarios.",
  "takeaways": "This research paper offers valuable insights for JavaScript developers working with LLM-based multi-agent systems, particularly in achieving robust cooperation. Here are some practical examples applied to web development scenarios:\n\n**1. Decentralized Autonomous Organizations (DAOs):**\n\n* **Scenario:** Building a DAO for managing a shared resource (e.g., community fund, cloud storage) where members (agents) vote on proposals.\n* **Challenge:** Ensuring fair and robust voting even if some agents are malicious or faulty.\n* **Solution:** Implement correlated εGrounded Bots as described in the paper. Each agent's bot evaluates proposals by simulating other agents' bots and voting based on the simulated outcomes. The shared randomness (using a verifiable random function in a blockchain context) ensures consistent simulation and helps prevent manipulation.  A JavaScript library like `ethers.js` could interact with the blockchain for randomness and voting.\n\n**2. Collaborative Content Creation:**\n\n* **Scenario:** Developing a platform for collaborative writing, code development, or design where multiple users contribute simultaneously.\n* **Challenge:** Maintaining consistency and avoiding edit conflicts while ensuring fairness and preventing one user from dominating the process.\n* **Solution:** Employ uncorrelated εGrounded Bots for conflict resolution. Each user's bot simulates other users' potential edits and proposes a merged version based on the simulations. The framework can then apply a consensus mechanism among the bot-proposed versions.  A library like `Yjs` or `ShareDB` could manage shared document state and handle synchronization.\n\n**3. Multi-User Gaming:**\n\n* **Scenario:** Creating a real-time multi-player web game with complex interactions and strategic decision-making.\n* **Challenge:** Designing bots that can play strategically and adapt to other players' behavior, especially in situations with incomplete information.\n* **Solution:** Utilize uncorrelated εGrounded Bots as game AI agents. Each bot simulates other players' possible actions and chooses its moves based on the simulated game outcomes. LangChain tools and the game’s JavaScript framework (e.g., Phaser, Babylon.js) can handle client-side bot execution.\n\n**4. Automated Negotiation and Bargaining:**\n\n* **Scenario:** Building an e-commerce platform where buyers and sellers can negotiate prices.\n* **Challenge:** Creating agents that can negotiate effectively and reach mutually beneficial agreements without requiring constant human intervention.\n* **Solution:** Implement uncorrelated εGrounded Bots as negotiating agents.  Each bot simulates the opponent's potential offers and counteroffers, adjusting its own strategy based on the simulations. This approach allows exploring different strategies under different assumptions without explicit game theoretic calculations. Node.js, along with a negotiation framework, could handle the backend interactions.\n\n\n**JavaScript Implementation Considerations:**\n\n* **LLM Integration:**  Use a JavaScript LLM wrapper like `LangChain.js` to access the LLM for generating bot actions given a particular context (simulated history and game state).\n* **Agent Framework:** Design a generic agent framework in JavaScript to manage bot instances, communication, and simulation logic.\n* **Shared Randomness (Correlated Bots):** If applicable, implement mechanisms for generating and distributing shared randomness using cryptographic libraries or blockchain interactions.\n* **Memoization:**  For improved performance, implement memoization to cache the results of simulations as suggested in the paper. This can be done using JavaScript's built-in `Map` or libraries like `memoizee`.\n\n\nBy adopting these insights and considering the practical implementation details, JavaScript developers can build more robust and sophisticated LLM-based multi-agent systems for various web applications. The concept of simulation-based program equilibrium opens up new possibilities for designing agents that can cooperate effectively even in complex and dynamic environments.",
  "pseudocode": "The paper contains two pseudocode blocks which can be translated to JavaScript as follows:\n\n**Algorithm 1: Correlated εGroundedπBot**\n\n```javascript\nfunction correlatedGroundedBot(otherPrograms, randomSequenceR, randomSequenceX) {\n  // Determine the 'time step' T\n  let T = 0;\n  while (randomSequenceR[T] >= epsilon) {\n    T++;\n  }\n\n  // If T = 0, immediately output the policy's action for the empty history\n  if (T === 0) {\n    return policy(null, randomSequenceR[0], randomSequenceX[0]);\n  }\n\n  // Simulate other programs at earlier time steps\n  let simulatedActions = [];\n  for (let t = 1; t <= T; t++) {\n    let currentActions = [];\n    for (let j = 0; j < otherPrograms.length + 1; j++) { // Include self\n      let program = j < otherPrograms.length ? otherPrograms[j] : correlatedGroundedBot; // Recursively call self\n      let truncatedR = randomSequenceR.slice(T + 1 - t);\n      let action = applyStar(program, otherPrograms, truncatedR, randomSequenceX); // Use applyStar \n      currentActions.push(action);\n    }\n    simulatedActions = simulatedActions.concat(currentActions); // For complete history access (optional)\n  }\n\n  return policy(simulatedActions, randomSequenceR[0], randomSequenceX[0]);\n}\n\n// Helper function (implementation depends on the specific definition in the paper)\nfunction applyStar(program, otherPrograms, r, x){\n //Implementation as described in the paper \n}\n\n\n// Example usage\nlet epsilon = 0.1; // Example value for epsilon. Should be between 0 and 1\nlet policy = (history,r0,x0)=> {\n//Example policy\n  return actions[0]; // returns the first available action in the list. For Example 1, this could return 'C'.\n};\nlet actions = ['C','D','P2','P3']; //For example 1.\nlet otherPrograms = []; // Other programs in the game\n\n// Generate random sequences. In a real application, these should be cryptographically secure\nlet randomSequenceR = [];\nlet randomSequenceX = [];\nfor (let i = 0; i < 1000; i++) { // Generate a sufficiently long sequence.\n  randomSequenceR.push(Math.random());\n  randomSequenceX.push(Math.random());\n}\n\nlet myAction = correlatedGroundedBot(otherPrograms, randomSequenceR, randomSequenceX);\n\nconsole.log(\"My Action:\", myAction);\n\n```\n\n**Explanation:** This algorithm defines a bot that plays a repeated game. It uses a shared source of randomness (`randomSequenceR` and `randomSequenceX`) with other bots. It first determines its \"time step\" `T` based on the shared randomness.  If `T` is 0, it immediately chooses an action based on its policy (`policy`). Otherwise, it simulates games at previous time steps (from 1 to `T`) by recursively calling itself and other programs, manipulating the provided randomness. The `applyStar` function is a key part of this algorithm, handling program execution and restricting access to the private random sequence `randomSequenceX`. This bot can cooperate with other similar bots to achieve equilibrium in repeated games.\n\n\n\n**Algorithm 2: Uncorrelated εGroundedπBot**\n\n```javascript\nfunction uncorrelatedGroundedBot(otherPrograms, randomSequence) {\n\n  let T = 0;\n  while (randomSequence[T] >= epsilon) {\n    T++;\n  }\n\n  if (T === 0) {\n    return policy(null,randomSequence.slice(0,1));//Empty history and slice from r_0 to r_0.\n  }\n\n  let simulatedActions = [];\n  for (let t = 1; t <= T; t++) {\n    let currentActions = [];\n    for (let j = 0; j < otherPrograms.length + 1; j++) {\n       let program = j < otherPrograms.length ? otherPrograms[j] : uncorrelatedGroundedBot; // Recursively call self\n      let truncatedR = randomSequence.slice(T + 1 - t);\n\n      currentActions.push(apply(program, otherPrograms, truncatedR)); \n    }\n    simulatedActions = simulatedActions.concat(currentActions); // Optional: for access to full history.\n  }\n\n  return policy(simulatedActions,randomSequence.slice(0,T+1));//slice from r_0 to r_T.\n}\n\n\n//Helper function (implementation depends on the specific definition in the paper)\n\nfunction apply(program, otherPrograms, randomSequence){\n //Implementation as described in the paper.\n}\n\n\n//Example usage:\n\nlet epsilon = 0.1; // Example value. Should be between 0 and 1\n\nlet policy = (history,r)=> {\n\n  //Example policy: always return the first available action\n  return actions[0]; //Could return 'C' for example 1.\n};\n\nlet actions = ['C','D','P2','P3']; //For Example 1.\n\n//Other players' programs (could be empty in the beginning)\nlet otherPrograms = [];\n\n//Generate a random sequence of numbers\nlet randomSequence = [];\n\nfor (let i = 0; i < 1000; i++) { //Generate a sufficiently long sequence\n  randomSequence.push(Math.random());\n}\n\n//Call the uncorrelatedGroundedBot function to get an action\nlet myAction = uncorrelatedGroundedBot(otherPrograms, randomSequence);\n\n//Print the action\nconsole.log(\"My Action:\", myAction);\n```\n\n\n**Explanation:** Similar to the correlated version, this algorithm simulates a repeated game but uses independent sources of randomness (`randomSequence`) for each bot. It determines its \"time step\" T and plays according to its policy if `T` is 0.  If `T` is greater than 0, it simulates previous time steps by recursive calls to itself and other programs. The key difference is the absence of the `applyStar` function and private random sequence `randomSequenceX`, reflecting the uncorrelated nature of the randomness. This algorithm still aims for cooperation but relies on individual random sequences.\n\n\n\n**Key differences between the algorithms:**\n\n* **Shared vs. Independent Randomness:** Algorithm 1 uses two shared random sequences across all bots, while Algorithm 2 provides each bot with its own independent random sequence.\n* **applyStar vs. apply:**  Algorithm 1 employs `applyStar`, which screens off dependence on private random sequences, a mechanism absent in Algorithm 2's simpler `apply` function.  This screening is crucial for the correlated setting's properties.\n* **Policy Inputs:** The `policy` function in Algorithm 1 takes the initial elements from *both* random sequences as input, whereas in Algorithm 2, the policy in the `T=0` case gets only the first element of the single random sequence (r_0), and in the `T>0` case, it gets a slice of the random sequence from r_0 up to r_T. This difference in policy inputs stems directly from the differing access to randomness between the two algorithm types.",
  "simpleQuestion": "How can I build robust multi-agent game equilibria?",
  "timestamp": "2024-12-20T06:10:52.076Z"
}