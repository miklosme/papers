{
  "arxivId": "2504.09716",
  "title": "Dominated Actions in Imperfect-Information Games",
  "abstract": "Dominance is a fundamental concept in game theory. In strategic-form games dominated strategies can be identified in polynomial time. As a consequence, iterative removal of dominated strategies can be performed efficiently as a preprocessing step for reducing the size of a game before computing a Nash equilibrium. For imperfect-information games in extensive form, we could convert the game to strategic form and then iteratively remove dominated strategies in the same way; however, this conversion may cause an exponential blowup in game size. In this paper we define and study the concept of dominated actions in imperfect-information games. Our main result is a polynomial-time algorithm for determining whether an action is dominated (strictly or weakly) by any mixed strategy in n-player games, which can be extended to an algorithm for iteratively removing dominated actions. This allows us to efficiently reduce the size of the game tree as a preprocessing step for Nash equilibrium computation. We explore the role of dominated actions empirically in the â€œAll In or Fold\" No-Limit Texas Hold'em poker variant.",
  "summary": "This paper explores \"dominated actions\" in imperfect-information games, a concept from game theory.  Dominated actions are choices within a game that are always worse than alternative choices, regardless of what other players do.  The paper presents a polynomial-time algorithm to identify and remove these actions, effectively simplifying the game.  This is particularly relevant to extensive-form games (sequential decision-making), where converting to normal form (simultaneous actions) for analysis is computationally expensive.  Experiments in two-player poker illustrate how this technique can significantly reduce the game's complexity.\n\nFor LLM-based multi-agent systems, this research is relevant for optimizing agent decision-making.  Identifying and eliminating dominated actions could simplify the action space LLMs need to consider, potentially leading to faster and more efficient reasoning, especially in complex, multi-agent interactions with sequential actions like negotiations or strategic planning.  This could improve performance in scenarios where agents need to respond quickly or when computational resources are limited.",
  "takeaways": "This paper explores the concept of dominated actions in imperfect-information games, offering valuable insights for JavaScript developers building LLM-based multi-agent web applications.  Here's how a JavaScript developer can apply these insights:\n\n**1. Simplifying Multi-Agent Interactions:**\n\n* **Scenario:** Imagine building a web-based multi-agent simulation for resource allocation (e.g., assigning tasks in a project management app). Each agent (representing a team member) is powered by an LLM and interacts to negotiate task assignments.\n* **Application:** The concept of dominated actions helps identify and eliminate suboptimal agent behaviors. For instance, an agent consistently choosing to negotiate for tasks outside its expertise represents a dominated action. By pre-calculating or learning dominated actions during the simulation, you can significantly simplify the agent's decision-making process, resulting in faster convergence and improved resource allocation.  In JavaScript, you could implement this using a decision rule engine or within the agent's LLM prompting logic.\n\n* **Code Example (Conceptual):**\n\n```javascript\n// Inside the agent's decision-making logic\nfunction chooseAction(gameState) {\n  const availableActions = getAvailableActions(gameState);\n\n  // Filter out dominated actions (pre-calculated or learned)\n  const nonDominatedActions = availableActions.filter(action => !isDominated(action, gameState));\n\n  // Use the LLM to choose among non-dominated actions\n  const chosenAction = llm.chooseBestAction(nonDominatedActions, gameState);\n  return chosenAction;\n}\n```\n\n\n**2. Optimizing LLM Prompting:**\n\n* **Scenario:** Consider developing a collaborative writing application where multiple LLM-powered agents contribute to a document. Agents negotiate on content additions, edits, and style.\n* **Application:**  By analyzing the potential actions an agent can take within a specific context (e.g., suggesting an edit), you can identify dominated actions based on stylistic guidelines or factual accuracy.  Removing these actions from the LLM's prompt space directly prevents the agent from suggesting irrelevant or incorrect changes.  This significantly improves the quality of the generated content and reduces unnecessary LLM calls.\n\n* **Code Example (Conceptual):**\n\n```javascript\n// Constructing the LLM prompt\nfunction generatePrompt(context) {\n  let prompt = `Given the current text: ${context.text}, suggest improvements. Possible actions: `;\n\n  const validActions = getValidActions(context); // Filters out dominated actions based on style and factual accuracy\n\n  prompt += validActions.join(\", \");\n  return prompt;\n}\n```\n\n\n**3. Building More Efficient Agent Architectures:**\n\n* **Scenario:** You're designing a multi-agent system for a real-time strategy game in the browser.  Each agent controls a unit and makes decisions about movement, attacks, and resource gathering.\n* **Application:** Dominated actions can be identified in the game's rule set (e.g., attacking a heavily armored unit with a weak attack). By incorporating this knowledge into the agent's architecture, you can significantly reduce the search space for the LLM, leading to faster and more effective decision-making in real-time. You might implement this using a game engine like Phaser or Babylon.js.\n\n\n\n**4.  Experimenting with Iterative Dominance:**\n\n* **Scenario:** Developing a web-based negotiation platform where LLM-powered agents barter virtual goods.\n* **Application:** The paper describes *iterative removal* of dominated actions. You could implement this in JavaScript to simulate evolving agent strategies. After each round of negotiation, analyze the agents' actions and identify dominated strategies. Remove these and simulate the next round with the reduced strategy set. This helps understand long-term dynamics and emergent behavior in your multi-agent system.\n\n**JavaScript Frameworks/Libraries:**\n\n* **TensorFlow.js:** For implementing learning algorithms to identify dominated actions.\n* **LangChain:**  For managing prompts and interactions with LLMs.\n* **Game Engines (Phaser, Babylon.js):**  For creating interactive multi-agent simulations in the browser.\n* **Node.js with WebSockets:** For building real-time multi-agent systems.\n\n\n**Key Takeaway:** Dominated action analysis offers a powerful optimization tool for JavaScript developers.  By integrating these concepts into LLM-based multi-agent web applications, you can improve efficiency, reduce LLM costs, and build smarter, more strategic agents.  The examples provided are conceptual, but they highlight the potential to integrate these theoretical principles into practical web development scenarios.",
  "pseudocode": "The paper contains mathematical formulations of optimization problems, but they are expressed as linear programs (LPs) and not in a pseudocode format easily translatable to JavaScript.  While the paper describes the *concepts* of algorithms for finding dominated actions, it doesn't present them in pseudocode. Therefore, a direct conversion to JavaScript is not possible.\n\nHowever, I can outline the core logic behind the dominance checking algorithm described in the paper and suggest how a JavaScript developer might approach implementing it using available LP solvers.\n\n**Conceptual Algorithm for Dominance Checking in Imperfect-Information Games**\n\nThe paper describes a polynomial-time algorithm for determining if an action is dominated. The core idea involves formulating and solving a series of linear programs.  Here's a conceptual breakdown:\n\n1. **Sequence Form Representation:** Represent the extensive-form game using the sequence form, where each sequence of actions for each player is a variable.\n\n2. **Dominance Check as an LP:**  Formulate the problem of checking whether an action `c` (part of sequence `i` for player 1 at information set `I`) is dominated as a min-max optimization problem involving the payoff matrices and constraints related to reaching the information set `I`.\n\n3. **Conversion to Two Subproblems:** The min-max problem is converted into two simpler maximization subproblems (equations 3 and 4, related by equations 5, 6, 7 and 8 in the paper), which are easier to solve as separate LPs. Note: the variable `x` in the two simpler maximization subproblems represent different things, `x_2` and `x_1` respectively.\n\n4. **Solving the LPs:** Solve these linear programs using a standard LP solver.\n\n5. **Interpretation:** Compare the optimal objective values of the two subproblems to determine if action `c` is strictly dominated, weakly dominated, or not dominated.\n\n**Suggested JavaScript Implementation Approach:**\n\n1. **Game Representation:**  Create a JavaScript data structure to represent the extensive-form game (e.g., using a tree structure or a sequence-form representation).\n\n2. **LP Solver Integration:** Use a JavaScript library for solving linear programs (e.g., web-based solvers or JavaScript LP solvers like `javascript-lp-solver`).\n\n3. **Algorithm Implementation:**  Implement the logic described in steps 2-5 above.  This would involve constructing the appropriate matrices and constraints for the LPs based on the game representation and the action being checked, then calling the LP solver and interpreting the results.\n\n4. **Iterative Dominance:**  For iterated dominance, repeat the dominance check for all actions and players, removing dominated actions until no more dominated actions are found.\n\n\n**Example (Illustrative - requires an LP solver):**\n\n```javascript\n// Assuming you have a game representation and an LP solver\n\nfunction isDominated(game, player, informationSet, action) {\n  // 1. Construct LPs based on the game, player, information set, and action\n  const lp1 = constructLP1(game, player, informationSet, action);\n  const lp2 = constructLP2(game, player, informationSet, action);\n\n  // 2. Solve LPs using an LP solver\n  const result1 = solveLP(lp1);\n  const result2 = solveLP(lp2);\n\n  // 3. Compare objective values and determine dominance \n  if (result1.objectiveValue > result2.objectiveValue) {\n    return \"Strictly Dominated\";\n  } else if (result1.objectiveValue == result2.objectiveValue) {\n      const lp3 = constructLP3(game, player, informationSet, action);\n      const lp4 = constructLP4(game, player, informationSet, action);\n      const result3 = solveLP(lp3);\n      const result4 = solveLP(lp4);\n      if (result3.objectiveValue > result4.objectiveValue)\n          return \"Weakly Dominated\";\n      else\n          return \"Not Dominated\";\n  }\n  else {\n      return \"Not Dominated\";\n  }\n}\n\n// ... (functions to construct the LPs and interface with the LP solver)\n```\n\nThis is a high-level illustration. A full implementation would require substantial work to represent the game, construct and solve the LPs, and handle iterative dominance removal.  But it gives a starting point for JavaScript developers interested in implementing these concepts.",
  "simpleQuestion": "Can I efficiently remove dominated actions in imperfect-information games?",
  "timestamp": "2025-04-15T05:05:59.204Z"
}