{
  "arxivId": "2501.13200",
  "title": "SRMT: SHARED MEMORY FOR MULTI-AGENT LIFE-LONG PATHFINDING",
  "abstract": "Multi-agent reinforcement learning (MARL) demonstrates significant progress in solving cooperative and competitive multi-agent problems in various environments. One of the principal challenges in MARL is the need for explicit prediction of the agents' behavior to achieve cooperation. To resolve this issue, we propose the Shared Recurrent Memory Transformer (SRMT) which extends memory transformers to multi-agent settings by pooling and globally broadcasting individual working memories, enabling agents to exchange information implicitly and coordinate their actions. We evaluate SRMT on the Partially Observable Multi-Agent Pathfinding problem in a toy Bottleneck navigation task that requires agents to pass through a narrow corridor and on a POGEMA benchmark set of tasks. In the Bottleneck task, SRMT consistently outperforms a variety of reinforcement learning baselines, especially under sparse rewards, and generalizes effectively to longer corridors than those seen during training. On POGEMA maps, including Mazes, Random, and MovingAI, SRMT is competitive with recent MARL, hybrid, and planning-based algorithms. These results suggest that incorporating shared recurrent memory into the transformer-based architectures can enhance coordination in decentralized multi-agent systems. The source code for training and evaluation is available on GitHub: https://github.com/Aloriosa/srmt.",
  "summary": "This paper introduces Shared Recurrent Memory Transformer (SRMT), a novel architecture for improving coordination in multi-agent reinforcement learning (MARL) systems.  SRMT uses a shared memory mechanism that allows agents to indirectly communicate by reading and writing their individual memories into a shared space. This facilitates cooperation without explicit communication protocols.  Key for LLM-based multi-agent systems is the ability of the shared memory to store and retrieve complex information relevant to decision-making, enabling more effective collaboration and problem-solving in decentralized environments.  The paper demonstrates SRMT's effectiveness on multi-agent pathfinding tasks, showing improved performance and generalization compared to existing MARL baselines, especially in scenarios with limited feedback.  The shared recurrent memory aspect is particularly relevant to LLMs, which can leverage this mechanism to manage and process long sequences of information for coordinated action in multi-agent settings.",
  "takeaways": "This paper introduces the Shared Recurrent Memory Transformer (SRMT), a mechanism for improved coordination in multi-agent systems, particularly relevant for LLM-based agents in web development. Here's how a JavaScript developer can apply these insights:\n\n**1. Building Collaborative Web Applications:**\n\n* **Scenario:** Imagine developing a collaborative document editing application like Google Docs, but powered by multiple LLM agents. Each agent could specialize in a task like grammar correction, style suggestion, or content generation.\n* **SRMT Application:**  Instead of relying on explicit communication messages between agents, which can become complex and brittle, implement a shared memory using a JavaScript library like `Immer` for efficient immutable state updates. Each agent (represented as a JavaScript class) can read from and write to this shared memory (a JavaScript object).  The shared memory would contain the current document state, editing history, and agent-specific information. This allows agents to implicitly understand each other's actions and intentions, leading to smoother collaboration.\n* **Example:**\n\n```javascript\nimport produce from 'immer';\n\nconst sharedMemory = {\n  document: '',\n  history: [],\n  agentStates: {},\n};\n\nclass LLMAgent {\n  constructor(agentId) {\n    this.agentId = agentId;\n  }\n\n  act(sharedMemory) {\n    // Read from shared memory\n    const currentDocument = sharedMemory.document;\n\n    // Use LLM to generate new content or edits\n    const newContent = this.llm.generate(currentDocument);\n\n    // Update shared memory using Immer\n    return produce(sharedMemory, draft => {\n      draft.document += newContent;\n      draft.history.push({ agentId: this.agentId, change: newContent });\n      draft.agentStates[this.agentId] = { /* ... agent specific state */ };\n    });\n  }\n}\n```\n\n**2. Developing Multi-Agent Chatbots:**\n\n* **Scenario:**  Creating a customer service system with multiple specialized chatbot agents. One agent might handle order tracking, another deals with returns, and a third answers general questions.\n* **SRMT Application:**  Implement a shared memory to store the current conversation state, customer information, and agent responsibilities.  This allows agents to seamlessly transfer the conversation to the most appropriate agent without explicit handoff protocols.  You can use libraries like `Recoil` or `Zustand` for state management and synchronization.\n* **Example (using Zustand):**\n\n```javascript\nimport create from 'zustand';\n\nconst useSharedMemory = create(set => ({\n  conversation: [],\n  customer: null,\n  activeAgent: null,\n  setActiveAgent: (agentId) => set({ activeAgent: agentId }),\n  // ...other state updates\n}));\n\n// Inside each chatbot agent component:\nconst { conversation, customer, activeAgent, setActiveAgent } = useSharedMemory();\n\n// Agent logic based on shared state...\n```\n\n\n**3. Creating Interactive Game Environments:**\n\n* **Scenario:** Developing a web-based game with multiple AI-controlled characters, each with different objectives and behaviors.\n* **SRMT Application:**  Use shared memory to store the game state, character positions, and intentions. This allows characters to coordinate their actions without explicit communication, creating more realistic and dynamic gameplay. Libraries like `PixiJS` or `Phaser` for game development could integrate with the shared memory.\n* **Example Concept:**  Store character intentions (e.g., \"move to location X\") in the shared memory. Other agents can observe these intentions and react accordingly, even without direct messaging.\n\n**Key JavaScript Considerations:**\n\n* **State Management Libraries:** `Recoil`, `Zustand`, `Jotai`, or `Immer` are excellent for managing and synchronizing the shared memory.\n* **Asynchronous Operations:** Use Promises and async/await to manage asynchronous LLM calls and updates to the shared memory.\n* **Serialization:**  Consider efficient serialization/deserialization of shared memory data, especially when working with complex LLM outputs.\n\n\nBy incorporating these examples and principles, JavaScript developers can leverage the power of SRMT to build sophisticated and coordinated multi-agent AI systems for web applications, overcoming the limitations of traditional communication-based approaches.  Experimentation and further research into efficient JavaScript implementations of shared memory for LLMs will unlock even greater potential for this innovative approach.",
  "pseudocode": "No pseudocode block found.",
  "simpleQuestion": "Can shared memory improve multi-agent pathfinding?",
  "timestamp": "2025-01-24T06:04:31.655Z"
}