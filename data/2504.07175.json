{
  "arxivId": "2504.07175",
  "title": "Self-organisation of common good usage and an application to Internet services",
  "abstract": "Abstract\n\nNatural and human-made common goods present key challenges due to their susceptibility to degradation, overuse, or congestion. We explore the self-organisation of their usage when individuals have access to several available commons but limited information on them. We propose an extension of the Win-Stay, Lose-Shift (WSLS) strategy for such systems, under which individuals use a resource iteratively until they are unsuccessful and then shift randomly. This simple strategy leads to a distribution of the use of commons with an improvement against random shifting. Selective individuals who retain information on their usage and accordingly adapt their tolerance to failure in each common good improve the average experienced quality for an entire population. Hybrid systems of selective and non-selective individuals can lead to an equilibrium with equalised experienced quality akin to the ideal free distribution. We show that these results can be applied to the server selection problem faced by mobile users accessing Internet services and we perform realistic simulations to test their validity. Furthermore, these findings can be used to understand other real systems such as animal dispersal on grazing and foraging land, and to propose solutions to operators of systems of public transport or other technological commons.",
  "summary": "This paper explores how individuals choose between multiple shared resources (\"common goods\") when each individual's usage diminishes the resource's quality for everyone. It proposes a simple \"Win-Stay, Lose-Shift\" (WSLS) strategy: stick with a resource as long as it's satisfactory; switch randomly when it's not.  This leads to surprisingly good distribution of usage.  Introducing \"selective\" agents who adapt their tolerance for poor quality further improves the overall system, approaching optimal distribution.  A key application is server selection in mobile networks, where users can choose between servers with different capacities and delays. Simulations validate the effectiveness of WSLS and adaptive tolerance in optimizing resource usage, even under fluctuating demand.\n\nFor LLM-based multi-agent systems, this work suggests: 1) Simple, localized strategies like WSLS can be effective for coordinating resource usage without complex communication or global knowledge. 2) Adaptability (like selective tolerance) further improves efficiency and robustness. 3) These concepts can be applied to managing computational resources in LLM-based multi-agent applications, potentially optimizing performance and cost by dynamically distributing workloads across available compute servers or LLMs with different capabilities.",
  "takeaways": "This paper presents a compelling model for distributed resource management applicable to LLM-based multi-agent web applications. Here's how a JavaScript developer can translate these insights into practical implementations:\n\n**1. LLM-Powered Chatbots in Customer Service:**\n\n* **Scenario:** Multiple LLM-powered chatbots handle customer service requests. Each chatbot has different strengths (e.g., specialized in different product categories) and can handle a limited number of concurrent chats before performance degrades.\n* **Applying Win-Stay, Lose-Shift (WSLS):**  A routing agent can assign incoming chats to chatbots using WSLS.  If a chatbot successfully resolves a chat (measured by customer satisfaction or resolution time), the agent continues routing chats to that bot. If a chat fails (e.g., low satisfaction, timeout), the agent randomly assigns the next chat to a different bot.\n* **JavaScript Implementation:**\n    * Use Node.js with a message queue (e.g., RabbitMQ, Kafka) for routing.\n    * Track chatbot performance metrics (e.g., resolution time, customer satisfaction) using a database (e.g., MongoDB, PostgreSQL).\n    * Implement the WSLS logic in the routing agent using JavaScript.\n\n**2. Collaborative Content Creation with LLMs:**\n\n* **Scenario:** Multiple LLMs contribute to a shared document (e.g., story writing, code generation). Each LLM has different writing styles or coding proficiencies and contributes in turns.\n* **Applying WSLS with Selective Tolerance:** Each LLM could have a \"tolerance\" level for unsatisfactory contributions from other LLMs. If a contribution is deemed unsatisfactory (measured by quality metrics, human feedback, or internal consistency checks), the LLM could either request a revision or take over that section itself.  The tolerance level can adapt based on the historical performance of other LLMs.\n* **JavaScript Implementation:**\n    * Use a collaborative editing framework (e.g., ProseMirror, CKEditor 5) to manage the shared document.\n    * Implement LLM interactions using a JavaScript library for LLM APIs (e.g., LangChain, LlamaIndex).\n    * Define quality metrics and tolerance thresholds within each LLM agentâ€™s JavaScript logic.\n\n**3. Distributed Task Allocation in Serverless Functions:**\n\n* **Scenario:** Serverless functions powered by LLMs perform various tasks (e.g., image processing, text summarization). Each function has different performance characteristics and cost profiles depending on the cloud provider or region.\n* **Applying WSLS with Adaptive Tolerance:**  A task manager can distribute incoming tasks to serverless functions using WSLS, considering cost and latency as performance metrics. Adaptive tolerance allows the task manager to dynamically adjust its preferences for different functions based on their real-time performance and cost fluctuations.\n* **JavaScript Implementation:**\n    * Use a serverless framework (e.g., Serverless Framework, AWS SAM) to manage the functions.\n    * Monitor function performance (e.g., execution time, cost) using cloud provider monitoring tools.\n    * Implement the adaptive WSLS logic in the task manager using JavaScript.\n\n**4. Decentralized Autonomous Organizations (DAOs) with LLM Agents:**\n\n* **Scenario:** LLM agents participate in a DAO, making decisions based on proposals and voting.  Different agents have different expertise and risk tolerance.\n* **Applying WSLS with Hybrid Systems:** Combine reactive (WSLS) and deliberative agents within the DAO. Some agents could vote based on the success or failure of previous similar proposals (WSLS), while others analyze proposals in more depth using advanced reasoning and personalized tolerance thresholds.\n* **JavaScript Implementation:**\n    * Use a blockchain platform (e.g., Ethereum, Cosmos) to manage the DAO and voting mechanisms.\n    * Implement LLM agents' decision-making logic using JavaScript and LLM APIs.\n\n\n**Key JavaScript Libraries and Frameworks:**\n\n* **LLM APIs:** LangChain, LlamaIndex, OpenAI's JavaScript library.\n* **Message Queues:** RabbitMQ, Kafka.\n* **Databases:** MongoDB, PostgreSQL, Redis.\n* **Serverless Frameworks:** Serverless Framework, AWS SAM, Azure Functions, Google Cloud Functions.\n* **Collaborative Editing:** ProseMirror, CKEditor 5, Quill.\n* **Blockchain Platforms (for DAOs):** Web3.js, Ethers.js.\n\nBy combining these tools and techniques, JavaScript developers can leverage the principles presented in the paper to create robust, adaptable, and efficient LLM-based multi-agent web applications. Remember that the specific implementation will depend on the complexity of the application and the characteristics of the LLMs being used.  The paper's core concepts provide a strong theoretical foundation for practical experimentation.",
  "pseudocode": "```javascript\n// Adaptive Tolerance Method\n\nclass User {\n  constructor(numServers, initialTolerance, learningRate, initialFailureProb) {\n    this.numServers = numServers;\n    this.estimatedFailureProbs = Array(numServers).fill(initialFailureProb);\n    this.tolerances = Array(numServers).fill(initialTolerance);\n    this.learningRate = learningRate;\n    this.currentServer = Math.floor(Math.random() * numServers); // Initial server selection\n    this.failureCount = 0;\n  }\n\n  updateEstimatedFailureProb(serverIndex, numAttempts) {\n    this.estimatedFailureProbs[serverIndex] = (1 - this.learningRate) * this.estimatedFailureProbs[serverIndex] + \n                                            this.learningRate * (this.tolerances[serverIndex] / numAttempts);\n  }\n\n  updateTolerance(minFailureProbServer) {\n    if (this.estimatedFailureProbs[this.currentServer] > this.estimatedFailureProbs[minFailureProbServer] &&\n        this.tolerances[this.currentServer] > 1) {\n      this.tolerances[this.currentServer]--;\n      this.tolerances[minFailureProbServer]++;\n    }\n  }\n\n\n  chooseServer() {\n    let minFailureProb = Math.min(...this.estimatedFailureProbs);\n    let minFailureProbServer = this.estimatedFailureProbs.indexOf(minFailureProb);\n\n    this.updateTolerance(minFailureProbServer);\n\n    this.currentServer = Math.floor(Math.random() * this.numServers); // Random server selection\n    this.failureCount = 0; \n  }\n\n  useServer(serverFailureProbability) { // Simulates a user attempting to use a server\n    let failed = Math.random() < serverFailureProbability;  // Simulate usage attempt\n    if (failed) {\n      this.failureCount++;\n      if (this.failureCount >= this.tolerances[this.currentServer]) {\n          this.chooseServer();\n      }\n    }\n\n     return !failed; // Return success/fail for simulation purposes\n\n  }\n\n  learn(serverIndex, numAttempts) {\n    this.updateEstimatedFailureProb(serverIndex, numAttempts);\n  }\n}\n\n\n// Example usage (simplified simulation loop):\n\nlet numServers = 3;\nlet users = [];\nfor(let i = 0; i < 1000; i++){\n  users.push(new User(numServers, 5, 0.1, 0));\n}\n\n\nfor (let time = 0; time < 1000; time++) {\n  let serverLoads = Array(numServers).fill(0);\n\n\n  for (let user of users) {\n    serverLoads[user.currentServer]++;\n  }\n\n  for (let user of users) {\n\n    let serverFailureProbability =  serverLoads[user.currentServer]/1000; // Example failure probability based on load\n    let successfulAttempt = user.useServer(serverFailureProbability);\n    if(successfulAttempt){\n      user.learn(user.currentServer, serverLoads[user.currentServer]);\n\n    }\n\n  }\n //... Rest of the simulation logic\n\n}\n\n\n```\n\n**Explanation:**\n\nThe JavaScript code implements the adaptive tolerance algorithm described in the paper. The algorithm aims to distribute users among multiple servers (common goods) to minimize the overall failure rate. It achieves this by having users dynamically adjust their tolerance for failures on each server based on their individual experience.\n\n\n1. **User Class:** Represents a user with properties like estimated failure probabilities for each server, tolerance for failures on each server, and a learning rate.\n\n2. **updateEstimatedFailureProb():** Updates the estimated failure probability of a server based on the user's experience (number of attempts vs. failures).\n\n3. **updateTolerance():** Adjusts the user's tolerance for a server. If the current server's estimated failure probability is higher than the lowest estimated failure probability among all servers, the tolerance for the current server is decreased, and the tolerance for the best-performing server is increased. This encourages users to shift away from poorly performing servers.\n\n4. **chooseServer():**  Selects a new server randomly. This happens when the user's tolerance for failures on the current server is reached.\n\n5. **useServer():** Simulates a user's attempt to use a server. It returns `true` if successful, `false` otherwise.\n\n6. **learn():** Calls `updateEstimatedFailureProb()` to update the estimated failure probabilities based on the usage attempt.\n\n\nThe provided example usage demonstrates a simplified simulation loop where users interact with servers, experience failures, and adapt their tolerances over time. The simulation updates the estimated failure probability only for the servers each user successfully used. The simulation keeps track of server loads and uses that information to derive each server's failure probability.  This code structure modularizes the adaptive tolerance logic, making it easier to integrate into a larger multi-agent simulation or a web application dealing with load balancing and resource allocation.",
  "simpleQuestion": "How can agents self-organize to share limited resources efficiently?",
  "timestamp": "2025-04-11T05:06:51.064Z"
}