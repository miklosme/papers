{
  "arxivId": "2503.05783",
  "title": "Knowledge representation and scalable abstract reasoning for simulated democracy in Unity",
  "abstract": "Abstract: We present a novel form of scalable knowledge representation about agents in a simulated democracy, e-polis, where real users respond to social challenges associated with democratic institutions, structured as Smart Spatial Types, a new type of Smart Building that changes architectural form according to the philosophical doctrine of a visitor. At the end of the game players vote on the Smart City that results from their collective choices. Our approach uses deductive systems in an unusual way: by integrating a model of democracy with a model of a Smart City we are able to prove quality aspects of the simulated democracy in different urban and social settings, while adding ease and flexibility to the development. Second, we can infer and reason with abstract knowledge, which is a limitation of the Unity platform; third, our system enables real-time decision-making and adaptation of the game flow based on the player's abstract state, paving the road to explainability. Scalability is achieved by maintaining a dual-layer knowledge representation mechanism for reasoning about the simulated democracy that functions in a similar way to a two-level cache. The lower layer knows about the current state of the game by continually processing a high rate of events produced by the in-built physics engine of the Unity platform, e.g., it knows of the position of a player in space, in terms of his coordinates x,y,z as well as their choices for each challenge. The higher layer knows of easily-retrievable, user-defined abstract knowledge about current and historical states, e.g., it knows of the political doctrine of a Smart Spatial Type, a player's philosophical doctrine, and the collective philosophical doctrine of a community players with respect to current social issues.",
  "summary": "This paper details the design and implementation of e-polis, a multi-agent serious game built in Unity, simulating a democratic process in a smart city. Players interact with \"Smart Spatial Types\" (buildings) that change form based on player choices in response to socio-political dilemmas. The system uses a dual-layer knowledge representation architecture with a lower layer tracking real-time game events and a higher layer inferring abstract knowledge about player beliefs and city state.\n\nKey points relevant to LLM-based multi-agent systems:\n\n* **Dual-layer knowledge representation:** Mirrors potential LLM agent architectures with a reactive layer processing immediate events and a deliberative layer reasoning about abstract concepts and historical context.\n* **Agent interaction shaping environment:** Player agents (and LLM agents potentially) directly influence the virtual environment, demonstrating emergent behavior based on individual choices and collective impact.\n* **Scalability and Reasoning:** The system addresses challenges of managing the extensive data produced by multi-agent simulations using a Rete-based reasoning engine, a concept applicable to rule-based LLM agent systems.\n* **Bridging Abstract and Concrete:** The system bridges abstract concepts (political doctrines) with concrete outcomes (building forms), suggesting how LLMs could ground abstract reasoning in tangible actions within virtual or physical spaces.\n* **Potential for LLM Enhancement:**  LLMs could enhance the system by generating diverse dilemmas, providing personalized narratives for agents, and modeling more nuanced social interactions.",
  "takeaways": "This paper presents a knowledge representation and reasoning system for a multi-agent simulated democracy game (e-polis) built in Unity. While the paper focuses on C# and Unity, the core concepts are transferable to JavaScript and web development, especially for building LLM-based multi-agent applications.  Here's how a JavaScript developer can apply these insights:\n\n**1. Dual-Layer Knowledge Representation:**\n\n* **Concept:** The paper uses a two-tiered approach: a Sensor Abstract Layer (SAL) for real-time, low-level events (like user actions, agent positions) and a Deductive Abstract Layer (DAL) for higher-level, derived knowledge (player political leanings, city state).\n* **JavaScript Application:**  For a web-based multi-agent app, you can implement this using JavaScript:\n    * **SAL:**  Use browser APIs and event listeners for low-level data. Store it in a reactive data store like Redux, MobX, or a simple reactive object.  Real-time communication libraries like Socket.IO can handle streaming events from agents.\n    * **DAL:** Use a rule engine (like Nools, json-rules-engine) or custom logic within your application state management to infer higher-level information from the SAL data. LLMs can significantly enhance the DAL by providing advanced reasoning, natural language understanding for user interactions, and even predicting future agent behavior based on historical data.\n\n**2. Agent Modeling and Interaction:**\n\n* **Concept:** The paper models agents (citizens) and spatial types (buildings) as interactive elements, with user choices influencing the state of the city.\n* **JavaScript Application:**  Represent agents as JavaScript objects with properties (political leaning, location, actions). Spatial types can also be JavaScript objects with associated states and visual representations. Use a JavaScript game engine like Phaser, Babylon.js, or Three.js for visualization and interaction.  LLMs can be used to generate agent dialog, actions, and even internal decision-making processes based on their \"personality\" and the current game state.\n\n**3. Rete Algorithm for Efficient Reasoning:**\n\n* **Concept:**  The paper uses the Rete algorithm for efficient rule matching.\n* **JavaScript Application:** Though a full Rete implementation in JavaScript might be complex, its core idea – caching intermediate results – is highly relevant. Implement caching strategies in your rule engine or custom logic to avoid redundant computations. LLMs, being computationally intensive, benefit significantly from efficient caching.\n\n**4. User Interface and Data Visualization:**\n\n* **Concept:**  The paper highlights the importance of presenting information effectively to the user.\n* **JavaScript Application:** Leverage JavaScript frameworks like React, Vue, or Svelte for building dynamic UIs to visualize the city, agent interactions, and derived knowledge.  Libraries like D3.js or Chart.js can create visualizations of user choices, agent distributions, and overall city state evolution.\n\n**5. Scaling to Big Data with Multi-Agent Simulation:**\n\n* **Concept:** The paper discusses using NetLogo for simulating a larger-scale version of the game.\n* **JavaScript Application:** JavaScript isn't ideal for highly computationally intensive simulations. However, for less demanding simulations, libraries like Agent-Based Modeling (ABM) libraries in JavaScript could be used. For complex scenarios, a server-side simulation (e.g., Python, Java) that communicates with the client-side (JavaScript) visualization might be more efficient.\n\n**Example Scenario: Simulating Online Deliberation:**\n\nImagine a website where users discuss a political issue. Each user is an agent with an LLM-powered personality and political stance.\n\n* **SAL:** Tracks user comments, votes, and interactions.\n* **DAL (LLM-powered):** Infers user sentiment, identifies opinion groups, moderates discussions, and even generates summaries or potential compromise solutions based on the ongoing discussion.\n* **Visualization:** Shows the discussion threads, user clusters, and evolution of the overall sentiment towards the issue.\n\nBy combining the knowledge representation and reasoning techniques of the paper with the power of LLMs and the flexibility of JavaScript web development, developers can create engaging and insightful multi-agent applications for diverse purposes like simulations, education, and online deliberation platforms.",
  "pseudocode": "The following pseudocode blocks were found and converted to JavaScript:\n\n**Pseudocode block 1:**  (Page 9) This pseudocode block defines a CLIPS rule for determining the prevailing philosophical doctrine (political leaning) chosen by players in response to a specific challenge (dilemma).\n\n```clips\n(defrule prevailing-choice\n    (H_UserAnsweredDilemma (uid ?uid1) (did ?did1) (choice ?cid1) (start-time ?st1))\n    (H_UserAnsweredDilemma (uid ?uid2) (did ?did2) (choice ?cid2) (start-time ?st2))\n    (= ?cid1 ?cid2)\n=>\n    modify (H_SameChoiceDifferentPlayer (did ?did) (choice ?cid1) (+ ?count 1) (start-time ?st1))\n\n(defrule find-max-value\n    (H_SameChoiceDifferentPlayer (did ?did) (choice ?cid1) (count ?count1) (start-time ?st1))\n    (not (H_SameChoiceDifferentPlayer (count ?count2&:(> ?count2 ?count1))))\n=>\n    (assert (H_PrevailingChoice (did ?did) (choice ?cid) (start-time ?st1)))\n    (printout t \"Choice \" ?cid \" is_the_maximum\" crlf))    \n```\n\n```javascript\nfunction findPrevailingChoice(answers) {\n    const choiceCounts = {}; \n    for (const answer of answers) {\n      if (answer.did === answers[0].did) { // Consider only answers for the same dilemma\n        if (choiceCounts[answer.choice]) {\n            choiceCounts[answer.choice].count++;\n        } else {\n            choiceCounts[answer.choice] = { count: 1, start_time: answer.start_time };\n        }\n      }\n    }\n\n    let prevailingChoice = null;\n    let maxCount = 0;\n\n    for (const choice in choiceCounts) {\n        if (choiceCounts[choice].count > maxCount) {\n            maxCount = choiceCounts[choice].count;\n            prevailingChoice = {\n                did: answers[0].did,  // Assuming all answers are for the same dilemma\n                choice: choice,\n                start_time: choiceCounts[choice].start_time\n            };\n        }\n    }\n\n    if (prevailingChoice) {\n        console.log(\"Choice\", prevailingChoice.choice, \"is_the_maximum\");\n    }\n\n    return prevailingChoice; \n}\n\n// Example usage:\nconst answers = [\n    { uid: 1, did: 1, choice: \"1\", start_time: 1000 },\n    { uid: 2, did: 1, choice: \"1\", start_time: 1020 },\n    { uid: 3, did: 1, choice: \"3\", start_time: 1080 },\n    { uid: 4, did: 1, choice: \"2\", start_time: 1100 },\n    { uid: 5, did: 1, choice: \"4\", start_time: 1200 },\n    { uid: 6, did: 2, choice: \"1\", start_time: 1300 }, // Different Dilemma id, so won't be processed\n];\n\nconst prevailing = findPrevailingChoice(answers);\nconsole.log(prevailing); // Output: { did: 1, choice: '1', start_time: 1000 }\n```\n\n**Explanation:** The JavaScript code iterates through the provided `answers` array. It maintains a `choiceCounts` object to store the count of each choice for a particular dilemma.  The `findPrevailingChoice` function then determines the `choice` with the highest `count` and returns an object representing the prevailing choice, including the dilemma ID (`did`) and the timestamp of the first occurrence of that choice (`start_time`).  The example usage demonstrates how to use the function and displays the result.\n\n\n\nThere are also numerous CLIPS rules defining game logic in Appendix D (Rules 1a, 1b, 2a, 2b, 2c, 3a, 3b, 3c, 3d, 3e, 4) that can be translated to JavaScript, but those would require more context to interpret and convert correctly. This response focuses on converting the provided pseudocode block in a functional manner.",
  "simpleQuestion": "How can I build a scalable, reasoning democracy sim in Unity?",
  "timestamp": "2025-03-11T06:03:00.068Z"
}