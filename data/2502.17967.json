{
  "arxivId": "2502.17967",
  "title": "LLM Knows Geometry Better than Algebra: Numerical Understanding of LLM-Based Agents in A Trading Arena",
  "abstract": "Recent advancements in large language models (LLMs) have significantly improved performance in natural language processing tasks. However, their ability to generalize to dynamic, unseen tasks, particularly in numerical reasoning, remains a challenge. Existing benchmarks mainly evaluate LLMs on problems with predefined optimal solutions, which may not align with real-world scenarios where clear answers are absent. To bridge this gap, we design the Agent Trading Arena, a virtual numerical game simulating complex economic systems through zero-sum games, where agents invest in stock portfolios. Our experiments reveal that LLMs, including GPT-40, struggle with algebraic reasoning when dealing with plain-text stock data, often focusing on local details rather than global trends. In contrast, LLMs perform significantly better with geometric reasoning when presented with visual data, such as scatter plots or K-line charts, suggesting that visual representations enhance numerical reasoning. This capability is further improved by incorporating the reflection module, which aids in the analysis and interpretation of complex data. We validate our findings on NASDAQ STOCK dataset, where LLMs demonstrate stronger reasoning with visual data compared to text. Our code and data are publicly available at https://github.com/wekjsdvnm/Agent-Trading-Arena.git.",
  "summary": "This research explores how Large Language Models (LLMs) perform in a simulated stock trading environment involving multiple AI agents. The study finds that LLMs are better at geometric reasoning with visual data (charts, graphs) than algebraic reasoning with textual data (numbers, tables).  Key points for LLM-based multi-agent systems: Visual data significantly improves LLM agent trading performance; a \"reflection\" module that allows agents to learn from past trades further enhances results, particularly with visual data; and these systems perform well even against traditional trading algorithms when tested on real-world NASDAQ data.  The research suggests that for complex numerical tasks in multi-agent systems, visual representation and learning from feedback are crucial for LLM effectiveness.",
  "takeaways": "This paper's key takeaway for JavaScript developers building LLM-based multi-agent web apps is the power of **visual data representation for enhancing numerical reasoning in LLMs**.  Here's how you can apply these insights:\n\n**1. Visualizing Trading Data:** Imagine building a multi-agent stock trading simulator in the browser. Instead of feeding raw textual data (price, volume, etc.) to your LLMs, use charting libraries like Chart.js, D3.js, or TradingView's charting library to create interactive candlestick charts, scatter plots, and line graphs of the trading data. This allows LLMs to grasp trends and relationships more effectively, leading to better trading strategies.\n\n```javascript\n// Example using Chart.js\nconst ctx = document.getElementById('myChart').getContext('2d');\nconst myChart = new Chart(ctx, {\n  type: 'candlestick',\n  data: {\n    datasets: [{\n      label: 'Stock Price',\n      data: stockData // Array of objects with open, high, low, close prices\n    }]\n  }\n});\n```\n\nThis visualized data can then be passed to the LLMs, either as an image, a data structure representing the chart elements, or via direct integration with the charting library's API.\n\n**2. Multi-Agent Collaboration with Visualizations:** For collaborative multi-agent scenarios (e.g., cooperative design, resource allocation), visualize shared data using libraries like Vis.js or Cytoscape.js.  LLMs could perceive the overall state through these visualizations, improving decision-making. For instance, in a resource allocation task, a graph could represent resource availability and agent needs.\n\n**3. Implementing a Reflection Module:**  The paper emphasizes the importance of a reflection module for strategy refinement. In JavaScript, this could be implemented using a combination of:\n\n* **Local Storage/IndexedDB:** To store the agent's trading history (short-term memory) and learned strategies (long-term memory) within the browser.\n* **Node.js with Express/Socket.IO:** To create a server-side component that aggregates agent performance, performs contrastive analysis (comparing best/worst performers), and generates feedback.\n* **LLM API integration:** To refine strategies based on the generated feedback.\n\n```javascript\n// Example of storing strategy in local storage\nlocalStorage.setItem('agentStrategy', JSON.stringify(currentStrategy));\n```\n\n**4. Data Preprocessing and Feature Engineering:** Before visualization, use JavaScript libraries like TensorFlow.js or NumJs to preprocess and engineer features from raw numerical data. This might include calculating moving averages, relative strength index (RSI), or other indicators, making patterns more apparent for the LLMs.\n\n**5. Framework Integration:** Integrate these concepts with JavaScript frameworks like React, Vue, or Angular to create interactive multi-agent web applications. For example, React components could manage visualization, while Redux could handle state management for agent interactions and memory.\n\n**6. Experimentation with LLM APIs:**  Experiment with different LLM APIs to explore their strengths in geometric reasoning. Services like Langchain.js can simplify this process, providing abstractions for interacting with various LLMs and managing prompts.\n\n**Example Scenario:** Consider building a multi-agent web application for collaborative urban planning. Each LLM-agent represents a stakeholder (residents, businesses, government).  Visualize the urban environment using a 3D model (e.g., using Three.js) and allow LLMs to interact by proposing changes. The visualization would represent the current state, enabling LLMs to understand the spatial relationships and impact of proposed modifications.  A reflection module could then analyze the collective impact of the agents' actions, providing feedback and guiding towards a consensus.\n\nBy applying these techniques, JavaScript developers can unlock the potential of LLMs for creating sophisticated, interactive multi-agent systems in the browser and beyond, pushing the boundaries of web development and AI.",
  "pseudocode": "```javascript\n// Algorithm 1: Environmental Interaction\nfunction environmentalInteraction(OPS, date, Z) {\n  for (const P of Persons) {\n    const A = OPS(date, P); // Retrieve agent P's actions on date 'date'\n    const [O, N, Q, Pricedeal] = extractActionDetails(A); // Extract details from action A\n\n    let [Pricecurr, Qtotal] = getStockData(N); // Retrieve current stock price and total quantity for stock N\n    Pricecurr = updateStockPrice(Q, F, Pricecurr, Pricedeal); // Update stock price based on the trade\n\n    if (O === \"buy\") {\n      const Cash = Pricecurr * Q;\n      if (Cash < P.Cash) { // Check if the agent has sufficient funds\n        Z = submitOrder(O, N, date, Pricecurr, Q); // Submit the buy order and update memory\n      }\n    } else if (O === \"sell\") {\n      const Hold = P.portfolio[N];\n      if (Hold !== null) { // Check if the agent holds the stock\n        const QN = Hold[\"Q\"] - Q;\n        if (QN > 0) { // Check if the agent is selling more than they own\n          Z = submitOrder(O, N, date, Pricecurr, Q); // Submit the sell order and update memory\n        }\n      }\n    }\n    updateMarket(date, Persons); // Update the overall market state\n  }\n  return Z; // Return updated memory\n}\n\n// Helper Functions (placeholders – these would need to be fleshed out based on your application's specifics)\nfunction extractActionDetails(action) { \n  // ... (logic to parse the action string and return order type, stock name, quantity, and deal price)\n  return [/* O, N, Q, Pricedeal */]; \n}\n\nfunction getStockData(stockName) { \n  // ... (logic to retrieve current stock price and total shares from storage)\n  return [/* Pricecurr, Qtotal */]; \n}\n\nfunction updateStockPrice(quantityTraded, fluctuationConstant, currentPrice, dealPrice) {\n  const totalShares = /* ... how are total shares determined? Fetch or calculate? */\n  return (quantityTraded * fluctuationConstant + currentPrice * totalShares) / (quantityTraded + totalShares);\n}\n\nfunction submitOrder(orderType, stockName, date, price, quantity) { \n  // ... (logic to record the trade in memory/database and potentially update agent's portfolio)\n  return /* updated Z */; \n}\n\nfunction updateMarket(date, persons) {\n  // ... (logic to update overall market statistics, other agents' views, etc.)\n}\n\n\n\n// Price Update Formula (equation 2)\nfunction updateStockPrice(quantityTraded, fluctuationConstant, currentPrice, dealPrice, totalShares) {\n  return (quantityTraded * fluctuationConstant + currentPrice * totalShares) / (quantityTraded + totalShares);\n}\n\n\n\n// Action Decision Making (equation 1 - simplified - core logic is within environmentalInteraction)\nfunction agentAction(Ins, Zdate, Sdate, t, Iters) {\n  return (t === Iters) ?  generateAction(Ins, Zdate, Sdate) : generateAction(Ins, Zdate, Sdate);  // Ψ function represented by generateAction\n}\n\n\nfunction generateAction(Ins, Zdate, Sdate) {\n  //  ... (core logic to use LLM to determine the next action based on instructions, memory, and strategy)\n  return /* action */;\n}\n\n\n\n\n\n```\n\n**Algorithm 1: Environmental Interaction**\n\n* **Purpose:** Simulates the stock market environment and handles agents' interactions.  It processes buy and sell orders, updates stock prices based on a defined formula, manages agent funds, and ensures consistent market behavior.\n* **Explanation:** This algorithm loops through each agent (in `Persons`). It retrieves the agent's action (buy, sell, or hold) using the `OPS` function. Then, it extracts the order details, fetches the current stock information, and updates the stock price based on the trade.  It handles insufficient funds for buy orders and insufficient shares for sell orders. Finally, it updates the overall market state after each agent's action.\n\n**Price Update Formula (Equation 2)**\n\n* **Purpose:** Calculates the new price of a stock after a trade.\n* **Explanation:** This formula adjusts the stock price based on the quantity traded, a fluctuation constant, the current price, the deal price, and the total number of shares available.  It's crucial for simulating dynamic price movements.\n\n**Action Decision Making (Equation 1)**\n\n* **Purpose:** Determines the agent's action (buy, sell, or hold).\n* **Explanation:** This equation is simplified in the JavaScript because the core logic is handled within the `environmentalInteraction` function.  The `generateAction` function represents the `Ψ` function from the paper, which uses the LLM to make trading decisions based on instructions, memory, and the current strategy.\n\n\nThis JavaScript code provides a more structured and functional implementation of the algorithms described in the paper, making it easier for developers to understand and integrate into a larger multi-agent trading simulation. It also includes placeholder comments to guide developers in adding the application-specific logic necessary for a fully functional system.  Remember that the provided JavaScript is a skeletal implementation, and the placeholder functions would need to be replaced with actual LLM integrations, data storage mechanisms, and market update logic.",
  "simpleQuestion": "Can LLMs reason better with charts than text data?",
  "timestamp": "2025-02-26T06:06:10.762Z"
}