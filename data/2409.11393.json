{
  "arxivId": "2409.11393",
  "title": "LLM-AGENT-UMF: LLM-BASED AGENT UNIFIED MODELING FRAMEWORK FOR SEAMLESS INTEGRATION OF MULTI ACTIVE/PASSIVE CORE-AGENTS",
  "abstract": "The integration of tools in LLM-based agents overcame the difficulties of standalone LLMs and traditional agents' limited capabilities. However, the conjunction of these technologies and the proposed enhancements in several state-of-the-art works followed a non-unified software architecture resulting in a lack of modularity. Indeed, they focused mainly on functionalities and overlooked the definition of the component's boundaries within the agent. This caused terminological and architectural ambiguities between researchers which we addressed in this paper by proposing a unified framework that establishes a clear foundation for LLM-based agents' development from both functional and software architectural perspectives. Our framework, LLM-Agent-UMF (LLM-based Agent Unified Modeling Framework), clearly distinguishes between the different components of an agent, setting LLMs, and tools apart from a newly introduced element: the core-agent, playing the role of the central coordinator of the agent which comprises five modules: planning, memory, profile, action, and securityâ€”the latter often neglected in previous works. Differences in the internal structure of core-agents led us to classify them into a taxonomy of passive and active types. Based on this, we proposed different multi-core agent architectures combining unique characteristics of various individual agents. For evaluation purposes, we applied this framework to a selection of state-of-the-art agents, thereby demonstrating its alignment with their functionalities and clarifying the overlooked architectural aspects. Moreover, we thoroughly assessed four of our proposed architectures by integrating distinctive agents into hybrid active/passive core-agents' systems. This analysis provided clear insights into potential improvements and highlighted the challenges involved in the combination of specific agents.",
  "summary": "This paper introduces a new framework called LLM-Agent-UMF to help software engineers better understand and build LLM-based multi-agent systems. It proposes a new component called the \"core-agent\" which acts as the brain of the agent, managing how LLMs interact with tools and the environment. Core-agents can be either \"active,\" meaning they can plan and make decisions, or \"passive,\" meaning they simply follow instructions. The paper also explores different ways to combine multiple core-agents, like having one active core-agent manage multiple passive ones. This approach is suggested as a simpler and more efficient way to build complex systems compared to traditional multi-agent systems. The framework is applied to existing LLM agents, demonstrating its usefulness in analyzing and comparing different designs and identifying potential areas for improvement, particularly regarding security and privacy.",
  "takeaways": "This paper offers valuable insights for JavaScript developers venturing into LLM-based multi-agent systems. Here's how you can apply its concepts to real-world web development scenarios:\n\n**1. Building Modular Agents with LangChain.js:**\n\n- **Core-Agent Implementation:** Utilize LangChain.js to structure your agents with distinct modules for planning, memory, profile, action, and security as suggested by the paper.  Each module can be a separate JavaScript class, enhancing code organization and reusability.\n    ```javascript\n    // Planning Module (LangChain.js)\n    class Planner {\n      constructor(llm) {\n        this.llm = llm;\n      }\n\n      async plan(goal) {\n        // Use this.llm to break down goal into steps using CoT or ToT\n      }\n    }\n\n    // Action Module (LangChain.js)\n    class Executor {\n      async execute(action, tools) {\n        // Select and execute actions using provided tools (e.g., APIs)\n      }\n    }\n    ```\n\n- **Active vs. Passive Agents:**  Choose the right core-agent type based on the application's complexity. For simple tasks like fetching data and displaying it, a passive core-agent using LangChain.js's tool integration capabilities would suffice.  For more complex scenarios, build active core-agents with planning and memory. \n\n**2. Collaborative Agents with Socket.IO:**\n\n- **Multi-Agent Communication:** Build collaborative agents that communicate in real-time using Socket.IO. An active core-agent could act as a central coordinator, assigning tasks to passive core-agents and managing their interactions.\n    ```javascript\n    // Active Core-Agent (Server-side, Node.js with Socket.IO)\n    io.on('connection', (socket) => {\n      socket.on('taskRequest', (data) => {\n        // Assign tasks to connected passive core-agents\n      });\n    });\n\n    // Passive Core-Agent (Client-side, JavaScript with Socket.IO)\n    socket.emit('taskRequest', { goal: 'fetch product details' });\n    socket.on('taskAssigned', (data) => {\n      // Execute task using tools and send results back\n    });\n    ```\n\n**3. Dynamic LLM Profiles with Prompt Engineering:**\n\n- **Profile Switching:**  Implement dynamic LLM profile switching in your agents using carefully crafted prompts. An active core-agent could manage these profiles based on the context of the user's interaction.\n    ```javascript\n    // Prompt Template with Profile Switching (LangChain.js)\n    const promptTemplate = new PromptTemplate({\n      template: `You are a helpful {profile}. {userQuery}`,\n      inputVariables: ['profile', 'userQuery']\n    });\n\n    // Profile Selection based on User Input\n    const profile = userQuery.includes('code') ? 'coder' : 'assistant'; \n    const prompt = promptTemplate.format({ profile, userQuery }); \n    ```\n\n**4. Security with LLM-Specific Guardrails:**\n\n- **Input/Output Sanitization:** Integrate existing LLM guardrail libraries or build your own to sanitize inputs and outputs within your core-agent's security module, preventing malicious prompts and harmful responses.\n    ```javascript\n    // Security Module Example\n    function sanitizeInput(userInput) {\n      // Filter out potentially harmful keywords or patterns\n      // Escape special characters to prevent code injection\n      return safeUserInput;\n    }\n\n    function validateOutput(llmResponse) {\n      // Check for offensive language, bias, or sensitive information\n      return safeResponse;\n    }\n    ```\n\n**5. Experimenting with JavaScript-Based Frameworks:**\n\n- **LangChain.js:**  Ideal for modular agent design, tool integration, and prompt management.\n- **Socket.IO:** Enables real-time communication between agents, crucial for collaborative scenarios.\n- **TensorFlow.js or Brain.js:** For implementing neural planners or custom agents with machine learning capabilities.\n\n**By combining the theoretical insights from this paper with practical JavaScript frameworks and tools, developers can create innovative and secure LLM-based multi-agent applications for a wide range of web development scenarios.**",
  "pseudocode": "No pseudocode block found.",
  "simpleQuestion": "How to build modular LLM agents?",
  "timestamp": "2024-09-18T05:02:35.351Z"
}