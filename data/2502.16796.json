{
  "arxivId": "2502.16796",
  "title": "MobileSteward: Integrating Multiple App-Oriented Agents with Self-Evolution to Automate Cross-App Instructions",
  "abstract": "Mobile phone agents can assist people in automating daily tasks on their phones, which have emerged as a pivotal research spotlight. However, existing procedure-oriented agents struggle with cross-app instructions, due to the following challenges: (1) complex task relationships, (2) diverse app environment, and (3) error propagation and information loss in multi-step execution. Drawing inspiration from object-oriented programming principles, we recognize that object-oriented solutions is more suitable for cross-app instruction. To address these challenges, we propose a self-evolving multi-agent framework named MobileSteward, which integrates multiple app-oriented StaffAgents coordinated by a centralized StewardAgent. We design three specialized modules in MobileSteward: (1) Dynamic Recruitment generates a scheduling graph guided by information flow to explicitly associate tasks among apps. (2) Assigned Execution assigns the task to app-oriented StaffAgents, each equipped with app-specialized expertise to address the diversity between apps. (3) Adjusted Evaluation conducts evaluation to provide reflection tips or deliver key information, which alleviates error propagation and information loss during multi-step execution. To continuously improve the performance of MobileSteward, we develop a Memory-based Self-evolution mechanism, which summarizes the experience from successful execution, to improve the performance of MobileSteward. We establish the first English Cross-APP Benchmark (CAPBench) in the real-world environment to evaluate the agents' capabilities of solving complex cross-app instructions. Experimental results demonstrate that MobileSteward achieves the best performance compared to both single-agent and multi-agent frameworks, highlighting the superiority of MobileSteward in better handling user instructions with diverse complexity.",
  "summary": "This paper introduces MobileSteward, a multi-agent framework designed to automate complex tasks spanning multiple mobile apps using LLMs.  It addresses challenges like intricate task relationships, diverse app environments, and error propagation in multi-step instructions.  Key LLM-related points include: using app-specialized LLMs (StaffAgents) coordinated by a central LLM (StewardAgent), dynamic task allocation based on predicted information flow, LLM-driven action prediction within each app, reflection and adjustment by the StewardAgent based on execution history, and memory modules in both agent types to learn from successful executions, enabling continuous improvement of the system's performance.  The researchers also introduce CAPBench, a new benchmark for evaluating cross-app instruction automation.",
  "takeaways": "This paper presents MobileSteward, a multi-agent framework for automating complex cross-app instructions on mobile phones, offering valuable insights transferable to LLM-based multi-agent web application development. Here's how a JavaScript developer can apply these concepts:\n\n**1. Object-Oriented Agent Design:**\n\n* **Concept:**  MobileSteward uses app-oriented \"StaffAgents\" specialized for individual apps, managed by a central \"StewardAgent.\"  This mirrors object-oriented programming, where objects (agents) have specific responsibilities.\n* **JavaScript Application:**  Design agents as JavaScript classes. For instance, a `ChatAgent` handles user interaction, a `SearchAgent` queries external APIs, a `TaskManagementAgent` manages workflow, and a `SummarizationAgent` summarizes information.  Each agent can be instantiated and managed by a central coordinator.\n* **Example:**\n\n```javascript\nclass ChatAgent {\n  constructor(llm) { this.llm = llm; }\n  async respond(message) {\n    const response = await this.llm.generate(message);\n    return response;\n  }\n}\n\nclass SearchAgent {\n  // ... (Implementation for searching)\n}\n// ... (Other agent classes)\n\nclass StewardAgent {\n  constructor(chatAgent, searchAgent, /* ... */) {\n    this.agents = { chat: chatAgent, search: searchAgent, /* ... */ };\n  }\n  async processRequest(userQuery) {\n    // Delegate tasks to appropriate agents based on query\n    const chatResponse = await this.agents.chat.respond(userQuery);\n    // ... further processing and agent coordination\n  }\n}\n\n\n// Initialize LLM (e.g., using Langchain.js or other LLM wrappers)\nconst llm = new LLM(/* ... */);\nconst chatAgent = new ChatAgent(llm);\nconst searchAgent = new SearchAgent();\n// ...(Other agent instances)\n\nconst steward = new StewardAgent(chatAgent, searchAgent, /* ... */);\n\nsteward.processRequest(\"Find me information about the latest JavaScript frameworks.\");\n\n```\n\n**2. Dynamic Task Allocation (Dynamic Recruitment):**\n\n* **Concept:**  MobileSteward dynamically assigns tasks to StaffAgents based on information flow and dependencies.\n* **JavaScript Application:** Use a task queue (e.g., using libraries like `bull` or `bee-queue`) to manage tasks and dependencies. The StewardAgent can analyze the user request and add tasks to the queue, specifying dependencies between them. Agents can subscribe to specific task types.\n* **Example (Conceptual - Integrating a task queue would require more code):**\n\n```javascript\n// StewardAgent\naddTaskToQueue(\"summarizeText\", { text: articleText }, { dependsOn: \"fetchArticle\" });\naddTaskToQueue(\"fetchArticle\", { url: articleURL });\n\n// SummarizationAgent (listens for 'summarizeText' tasks)\nqueue.process(\"summarizeText\", async (job) => { /* ... */ });\n```\n\n**3.  Error Handling and Information Transfer (Adjusted Evaluation):**\n\n* **Concept:**  MobileSteward includes mechanisms for error reflection and passing information between agents.\n* **JavaScript Application:** Implement error handling within each agent. Use a shared state management system (e.g., Redux, Zustand, or a server-side database) to allow agents to exchange information.  Log errors and agent interactions for debugging and analysis.  \n* **Example (Conceptual):**\n\n```javascript\n// SearchAgent\ntry {\n  const results = await searchAPI(query);\n  sharedState.searchResults = results; // Store results in shared state\n} catch (error) {\n  logError(error);\n  sharedState.searchError = error.message; // Signal an error\n}\n```\n\n**4. Continuous Improvement (Memory-based Self-Evolution):**\n\n* **Concept:** MobileSteward learns from successful executions to improve performance.\n* **JavaScript Application:**  Store successful execution paths and agent interactions in a database. Use this data to train or fine-tune the LLM, improving its ability to allocate tasks and generate agent actions. Explore reinforcement learning techniques if appropriate for your application.\n* **Example (Conceptual):**\n\n```javascript\n// After successful task completion:\ndatabase.insert({\n  userId: user.id,\n  task: taskDescription,\n  agentActions: agentInteractionLog,\n  result: taskResult\n});\n\n// Periodically retrain LLM on collected data\n```\n\n**5. Frontend Integration:**\n\nUse JavaScript frameworks like React, Vue, or Angular to build interactive frontends that visualize the agent interactions and task progress. This enhances transparency and provides user feedback.\n\nBy adapting these concepts and leveraging the flexibility of JavaScript and its ecosystem, developers can build powerful LLM-based multi-agent web applications that efficiently manage complex workflows and learn from experience, bringing the benefits of multi-agent AI research into real-world web development.",
  "pseudocode": "```javascript\n/**\n * MobileSteward Workflow\n *\n * Automates complex cross-app instructions on a mobile device using a multi-agent system.\n *\n * @param {string} instruction - The user's instruction.\n * @param {object} environment - The mobile phone environment (simulated or real).\n * @param {number} maxTries - Maximum number of attempts to complete the instruction.\n * @param {number} maxSteps - Maximum number of steps within each try.\n * @returns {array} - An array of execution histories for each StaffAgent's attempt.\n */\nasync function mobileSteward(instruction, environment, maxTries, maxSteps) {\n    const stewardAgent = new StewardAgent();\n    const staffExpertiseMemory = stewardAgent.staffExpertiseMemory; // Access memory\n    const taskGuidelineMemory = {}; // Initialize an empty object for task guidelines\n\n    const schedulingGraph = await stewardAgent.schedule(instruction, staffExpertiseMemory);\n    const executionHistories = [];\n\n    for (const [task, staffAgentId] of topologicalSort(schedulingGraph)) {\n        let tryCount = 0;\n        let reflectionTips = null;\n        let executionHistory = [];\n\n        while (tryCount < maxTries) {\n            tryCount++;\n            let stepCount = 0;\n            let previousState = null;\n            let plan = await StaffAgent.plan(task, taskGuidelineMemory[task] || [], staffAgentId); // provide empty array if no task-specific guidelines available\n            executionHistory = [];\n\n\n            while (stepCount < maxSteps) {\n                const currentState = environment.getState();\n                const action = await StaffAgent.predict(\n                    task,\n                    currentState,\n                    taskGuidelineMemory[task] || [], // provide an empty array if no task-specific guidelines are available\n                    previousState,\n                    plan,\n                    reflectionTips,\n                    staffAgentId\n                );\n\n                const actionSummary = StaffAgent.summarize(task, currentState, action, staffAgentId);\n                environment.updateState(action);\n\n                executionHistory.push({ state: currentState, action, summary: actionSummary });\n                previousState = currentState;\n                stepCount++;\n\n                if (action.type === \"FINISH\") break; // Exit if task is finished\n            }\n\n\n            const evaluation = await stewardAgent.evaluate(executionHistory, task);\n            if (evaluation === \"ERROR\") {\n                reflectionTips = await stewardAgent.reflect(executionHistory, task);\n\n            } else {\n                const [resultInfo, staffExpertise, taskGuideline] = await stewardAgent.extract(executionHistory, task);\n                for (const [currentTask, nextTask] of schedulingGraph) {\n                  if (currentTask === task) {\n                    nextTask.input = resultInfo; // Assuming tasks have an input property for receiving information\n                  }\n                }\n\n                stewardAgent.updateStaffExpertiseMemory(staffExpertise);\n\n                // Update or add the task guideline to the taskGuidelineMemory:\n                taskGuidelineMemory[task] = taskGuideline;\n\n                break; // Exit the try loop if successful\n            }\n        }\n        executionHistories.push(executionHistory);\n    }\n    return executionHistories;\n}\n\n\n// Helper function for topological sorting (implementation omitted for brevity)\nfunction topologicalSort(graph) {\n    // ... Implementation ...\n}\n\n\n\n/**\n * StewardAgent Class\n *  Handles task scheduling, evaluation, and memory updates.\n */\nclass StewardAgent {\n    constructor() {\n        this.staffExpertiseMemory = {}; // Initialize as an empty object\n    }\n\n    async schedule(instruction, memory) {/*...*/}\n    async evaluate(history, task) {/*...*/}\n    async reflect(history, task) {/*...*/}\n    async extract(history, task) {/*...*/}\n    updateStaffExpertiseMemory(expertise) {/*...*/}\n\n}\n\n\n/**\n * StaffAgent Class\n * Handles app-specific actions and plan execution.\n */\nclass StaffAgent{\n\n  static async plan(task, memory, agentId) {/*...*/}\n  static async predict(task, state, memory, previousState, plan, reflectionTips, agentId) {/*...*/}\n  static summarize(task, state, action, agentId){/*...*/}\n}\n\n```\n\n\n**Explanation:**\n\nThe core algorithm `mobileSteward` orchestrates the multi-agent system. It first uses `StewardAgent` to decompose the instruction and create a scheduling graph. Then, it iterates through tasks in the graph (topologically sorted to respect dependencies). For each task, a `StaffAgent` is invoked to execute the task.  The `StewardAgent` evaluates the execution and provides feedback.  If the execution fails, the `StaffAgent` retries with the feedback. This process repeats until the task is successful or the maximum tries are reached. The implemented version uses two classes, `StewardAgent` and `StaffAgent` and a helper function for topological sorting. This modularizes the code and makes it more maintainable. The `StewardAgent`'s memory, specifically `staffExpertiseMemory` is now properly accessed and used within the `schedule` function. Task Guideline Memory is implemented as a dictionary where keys are the task IDs and values are the corresponding guidelines. Finally, task guidelines are now correctly used within both `StaffAgent.plan` and `StaffAgent.predict` functions.\n\nThis JavaScript code provides a structure for implementing the MobileSteward algorithm and incorporates memory management, task scheduling, and agent interaction. Note that the implementations of the specific functions within the agent classes are placeholder comments and need to be filled in based on the paper's descriptions and the chosen LLM interactions. The code also includes error handling and feedback mechanisms as described in the paper.",
  "simpleQuestion": "How can self-evolving agents automate cross-app tasks?",
  "timestamp": "2025-02-25T06:05:27.959Z"
}