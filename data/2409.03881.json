{
  "arxivId": "2409.03881",
  "title": "Multi-agent Path Finding for Mixed Autonomy Traffic Coordination",
  "abstract": "Abstract-In the evolving landscape of urban mobility, the prospective integration of Connected and Automated Vehicles (CAVs) with Human-Driven Vehicles (HDVs) presents a complex array of challenges and opportunities for autonomous driving systems. While recent advancements in robotics have yielded Multi-Agent Path Finding (MAPF) algorithms tailored for agent coordination task characterized by simplified kinematics and complete control over agent behaviors, these solutions are inapplicable in mixed-traffic environments where uncontrollable HDVs must coexist and interact with CAVs. Addressing this gap, we propose the Behavior Prediction Kinematic Priority Based Search (BK-PBS), which leverages an offline-trained conditional prediction model to forecast HDV responses to CAV maneuvers, integrating these insights into a Priority Based Search (PBS) where the A* search proceeds over motion primitives to accommodate kinematic constraints. We compare BK-PBS with CAV planning algorithms derived by rule-based car-following models, and reinforcement learning. Through comprehensive simulation on a highway merging scenario across diverse scenarios of CAV penetration rate and traffic density, BK-PBS outperforms these baselines in reducing collision rates and enhancing system-level travel delay. Our work is directly applicable to many scenarios of multi-human multi-robot coordination.",
  "summary": "This paper introduces BK-PBS, a new algorithm for coordinating autonomous vehicles (CAVs) in mixed traffic with human drivers (HDVs). It tackles the challenge of unpredictable HDV behavior by:\n\n* **Predicting HDV actions:** Using a conditional prediction model trained on HDV driving data, it forecasts how HDVs might react to CAV maneuvers.\n* **Proactive planning:** Instead of treating HDVs as static obstacles, BK-PBS anticipates their actions and plans CAV trajectories to influence HDV behavior for smoother traffic flow.\n\nThis is relevant to LLM-based multi-agent systems because it demonstrates:\n\n* **Combining LLMs with traditional AI:**  The LLM (conditional prediction model) enhances a classical search-based AI algorithm (PBS).\n* **Value of behavior prediction:**  Proactively accounting for agent behavior, especially in mixed-autonomy settings, leads to more efficient coordination.",
  "takeaways": "This paper presents a novel approach to coordinating autonomous vehicles in mixed traffic environments, which can be translated to other LLM-based multi-agent AI applications in web development. Here are some practical examples for JavaScript developers:\n\n**1. Collaborative Editing with LLMs:**\n\n* **Scenario:** Imagine building a Google Docs-like collaborative writing application where multiple users, potentially aided by LLMs generating content suggestions, edit a document simultaneously. \n* **Applying BK-PBS:** Each LLM agent can be treated as a CAV, while human users act like less predictable HDVs. \n* **Implementation:**\n    * **Prediction Model:** Train an LLM (like GPT-3) on past editing patterns of users to predict their future actions (e.g., text insertions, deletions). This model becomes your `be` function.\n    * **M-A* with Motion Primitives:**  Instead of car maneuvers, your motion primitives become text editing operations. For example: \"insert word\", \"delete character\", \"start new paragraph\". The cost function in M-A* can be minimizing text conflicts or maximizing semantic coherence, as judged by another LLM.\n    * **Priority & Conflict Resolution:**  Use the priority concept from BK-PBS to handle conflicting edits. For instance, an LLM suggesting a major rewrite might have lower priority than a user making minor changes. You can visualize conflicts and resolutions using JavaScript libraries like `fabric.js` or `konva.js` for canvas manipulation.\n\n**2. AI-powered Chat Moderation:**\n\n* **Scenario:** Develop a chat application with multiple AI moderators (powered by LLMs) alongside human moderators, ensuring a safe and engaging environment.\n* **Applying BK-PBS:** AI moderators are CAVs, while humans, with their nuanced understanding of context, are HDVs.\n* **Implementation:**\n    * **Prediction Model:** Train an LLM to predict the potential impact of a message (toxicity, off-topic, etc.) based on chat history.\n    * **Motion Primitives:** Define moderation actions like \"flag message\", \"send warning\", \"ban user\".\n    * **Priority & Coordination:**  BK-PBS helps coordinate moderation actions. For instance, if an AI flags a message, human moderators (higher priority) can be notified for review before any drastic action. Libraries like `Socket.IO` can be used for real-time communication and action propagation.\n\n**3. JavaScript Libraries and Frameworks:**\n\n* **TensorFlow.js:** Train and run LLM prediction models directly in the browser for client-side prediction and faster response.\n* **Node.js:** Use Node.js to build the server-side logic for BK-PBS, managing agent communication, and handling priority queues.\n* **React/Vue.js:** These frameworks can be used to build the user interface for visualizing agent actions and conflicts in real-time.\n\n**Key Takeaways for JavaScript Developers:**\n\n* **LLMs as Agents:**  Think of LLMs not just as text generators, but as agents capable of planning and acting within a system.\n* **Prediction is Key:**  Investing in robust prediction models for user/agent behavior is crucial for successful multi-agent systems.\n* **Visualize and Experiment:**  Use JavaScript's visualization tools to understand agent interactions and fine-tune your BK-PBS implementation. \n\nBy adapting the concepts from this paper and leveraging the power of JavaScript and its ecosystem, developers can create innovative and engaging web applications empowered by LLM-based multi-agent AI systems.",
  "pseudocode": "```javascript\nfunction BK_PBS(C, H, o, be) {\n  // Initialize root node of Priority Tree (PT)\n  const root = { priority: {}, plan: {} };\n\n  // Initialize plan for all vehicles as empty\n  for (const i of [...C, ...H]) {\n    root.plan[i] = [];\n  }\n\n  // Update plan for all vehicles in the root node\n  for (const i of [...C, ...H]) {\n    const success = updatePlan(root, i, be);\n    if (!success) {\n      return \"No Solution\"; // No feasible plan found\n    }\n  }\n\n  // Calculate cost of root node based on vehicle speeds\n  root.cost = -Object.values(root.plan).reduce((sum, plan) => sum + plan.length, 0); \n\n  // Initialize stack for Depth-First Search with root node\n  const STACK = [root];\n\n  // Explore the Priority Tree\n  while (STACK.length > 0) {\n    const N = STACK.pop();\n\n    // If no collision in current node, it's a goal node\n    if (!hasCollision(N.plan)) {\n      return N.plan; // Return the collision-free plan\n    }\n\n    // Find first CAV-involved collision\n    const [i, j] = findFirstCollision(N.plan, C); \n\n    // Branch for both priority orders of colliding vehicles\n    for (const priority of [[i, j], [j, i]]) {\n      const Nprime = { ...N, priority: { ...N.priority, ...{[priority[0]]: priority[1]] } };\n\n      // Update plan for the vehicle with lower priority\n      const success = updatePlan(Nprime, priority[1], be);\n      if (success) {\n        // Add child node to stack, prioritize lower cost\n        STACK.push(Nprime);\n        STACK.sort((a, b) => a.cost - b.cost); \n      }\n    }\n  }\n\n  return \"No Solution\"; // No feasible plan found in the PT\n}\n\nfunction updatePlan(N, i, be) {\n  // Topological sort of vehicles based on priority in node N\n  const L = topologicalSort(N.priority, i); \n\n  for (const q of L) {\n    // Check for collision with higher priority vehicles\n    if (q === i || hasCollisionWithHigherPriority(N.plan, q, N.priority)) { \n\n      if (C.includes(q)) {\n        // Vehicle q is a CAV, replan using M-A*\n        N.plan[q] = MAstar(N.plan, q, N.priority); // Assuming MAstar function exists\n      } else {\n        // Vehicle q is a HDV, predict trajectory\n        const surroundings = getSurroundingVehicles(N.plan, q); // Get nearby vehicle states\n        N.plan[q] = be(surroundings, N.plan, q, N.priority); // Predict trajectory based on CAV plans\n\n        // Check if predicted trajectory leads to collisions\n        if (hasCollision(N.plan) || !MAstar(N.plan, q, N.priority)) {\n          return false; // Trajectory leads to collision, prune this branch\n        }\n      }\n    }\n  }\n  return true; // Plan successfully updated\n}\n```\n\n**Explanation:**\n\nThe code implements the BK-PBS algorithm for coordinating CAVs in mixed traffic, aiming to minimize collisions and travel delays. Here's a breakdown:\n\n- **`BK_PBS(C, H, o, be)`:** This function orchestrates the entire BK-PBS algorithm. \n    - `C`: Set of CAV agents.\n    - `H`: Set of HDV agents.\n    - `o`: Function to obtain the current observation (surrounding vehicle states) for a given vehicle.\n    - `be`: Conditional prediction model (e.g., a neural network) to predict HDV trajectories based on surrounding CAV actions.\n    - The function initializes a priority tree, iteratively resolves collisions by branching on priority orders, and returns a collision-free plan for all CAVs if found.\n\n- **`updatePlan(N, i, be)`:** This helper function updates the plan for a given vehicle `i` within a given node `N` of the priority tree.\n    - `N`: Current node in the priority tree.\n    - `i`: Index of the vehicle to update the plan for.\n    - It uses a topological sort to determine the order of vehicles to be planned, leveraging the `be` prediction model for HDVs and a multi-phase A* search (M-A*) for CAVs.\n\n**Purpose:**\n\nThe algorithm focuses on:\n\n- **Proactive Coordination:** BK-PBS aims to influence HDV behavior proactively by considering their predicted reactions to different CAV actions.\n- **Collision Avoidance:** The primary goal is to generate collision-free trajectories for all vehicles.\n- **Efficiency:** The algorithm aims to minimize travel delays, leading to smoother traffic flow.\n\n**Key Aspects:**\n\n- **Priority-Based Search (PBS):**  BK-PBS builds upon the PBS framework, systematically exploring different priority assignments between conflicting vehicles to resolve collisions.\n- **Conditional Prediction Model:** The integration of a prediction model (`be`) allows the algorithm to anticipate HDV behavior and plan CAV actions accordingly.\n- **Multi-Phase A* with Motion Primitives (M-A*):** This ensures that generated plans adhere to vehicle kinematic constraints while navigating a map represented with motion primitives instead of a grid.\n\nThis code provides a high-level structure of the BK-PBS algorithm. Implementing it would require defining additional functions like `hasCollision`, `findFirstCollision`, `topologicalSort`, `MAstar`, and potentially a more detailed implementation of the prediction model `be`.",
  "simpleQuestion": "How to coordinate CAVs and HDVs in traffic?",
  "timestamp": "2024-09-09T05:01:26.336Z"
}