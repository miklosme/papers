{
  "arxivId": "2412.11678",
  "title": "Loosely Synchronized Rule-Based Planning for Multi-Agent Path Finding with Asynchronous Actions",
  "abstract": "Multi-Agent Path Finding (MAPF) seeks collision-free paths for multiple agents from their respective starting locations to their respective goal locations while minimizing path costs. Although many MAPF algorithms were developed and can handle up to thousands of agents, they usually rely on the assumption that each action of the agent takes a time unit, and the actions of all agents are synchronized in a sense that the actions of agents start at the same discrete time step, which may limit their use in practice. Only a few algorithms were developed to address asynchronous actions, and they all lie on one end of the spectrum, focusing on finding optimal solutions with limited scalability. This paper develops new planners that lie on the other end of the spectrum, trading off solution quality for scalability, by finding an unbounded sub-optimal solution for many agents. Our method leverages both search methods (LSS) in handling asynchronous actions and rule-based planning methods (PIBT) for MAPF. We analyze the properties of our method and test it against several baselines with up to 1000 agents in various maps. Given a runtime limit, our method can handle an order of magnitude more agents than the baselines with about 25% longer makespan.",
  "summary": "This paper addresses the Multi-Agent Path Finding (MAPF) problem with asynchronous actions (MAPF-AA), meaning agents move at different speeds and don't act in lockstep.  It introduces Loosely Synchronized Rule-Based Planning (LSRP), a new algorithm that scales to hundreds of agents by sacrificing optimality for speed. LSRP leverages a priority-based planning approach and a caching mechanism to manage agents' asynchronous actions. A key extension, LSRP-SWAP, adds a swapping mechanism for agents to navigate complex environments where simple pushing is insufficient, like tree-like graphs.  Although LSRP/LSRP-SWAP generates longer plans than optimal algorithms, they are significantly faster and can handle orders of magnitude more agents, crucial for large-scale multi-agent web applications using LLMs.  This is particularly relevant for developers of LLM-based multi-agent systems, as asynchronous actions are more realistic and scalable than synchronous alternatives.",
  "takeaways": "This paper introduces Loosely Synchronized Rule-Based Planning (LSRP) for Multi-Agent Path Finding with Asynchronous Actions (MAPF-AA).  While the paper itself uses C++, the core concepts are directly applicable to JavaScript and LLM-powered multi-agent systems in web development. Here are practical examples:\n\n**Scenario 1: Collaborative Text Editing with LLMs**\n\nImagine a collaborative writing app where multiple users, assisted by LLMs, edit the same document simultaneously. Each LLM agent can perform actions like suggesting rephrasing, adding content, or checking grammar. These actions take varying amounts of time (asynchronous).  LSRP principles can be used to manage these actions:\n\n* **Agent Representation:**  Each LLM is represented as an agent in JavaScript.  Their current action, start time, and estimated completion time (duration) can be stored in an object:\n\n```javascript\nconst agent1 = {\n  id: 'agent1',\n  action: 'rephrase paragraph 2',\n  startTime: Date.now(),\n  duration: 5000 // estimated 5 seconds\n};\n```\n\n* **Conflict Resolution:**  If two LLMs want to modify the same paragraph simultaneously, a conflict arises.  LSRP’s priority system, implemented in JavaScript, can resolve this. The LLM with higher priority (e.g., based on user roles or task urgency) performs its action first, while the other agent waits (as in `WAITANDMOVE` in the paper).\n\n* **Loose Synchronization with Caching:**  A JavaScript `PriorityQueue` can be used to store pending actions, sorted by their estimated completion time.  A cache (like `Φ` in the paper) can store the planned future actions, enabling loose synchronization.\n\n* **Framework Integration:**  Frameworks like Yjs or ShareDB can handle the underlying data synchronization of the document.  LSRP manages the LLM agent actions on top of this.\n\n\n\n**Scenario 2: Multi-Agent Chatbots for Customer Support**\n\nConsider a website with multiple chatbot agents, each specialized in a different area (e.g., shipping, returns, product information). When a customer asks a question, LSRP can be used to route the question to the appropriate chatbot and manage their responses:\n\n\n* **Agent Skill Representation:** Each chatbot agent's skills can be represented in JavaScript, for example, using a scoring system:\n\n```javascript\nconst chatbotShipping = {\n  id: 'shippingBot',\n  skills: { shipping: 0.9, returns: 0.2, productInfo: 0.1 }\n};\n```\n\n* **Task Assignment (LSRP Adaptation):** An incoming customer question can be analyzed by an LLM to determine which chatbot is best suited. This LLM acts as a central \"dispatcher\" using the principles of LSRP to assign the task, considering each chatbot's current workload and response time (asynchronous action durations).\n\n* **Queue Management:** Use a JavaScript queue to manage incoming customer questions and the chatbots' responses. The dispatcher, using the adapted LSRP logic, adds the responses to the queue according to priorities and timings.\n\n* **Frontend Integration:** Frameworks like React, Vue, or Angular can be used to display the chatbot interactions on the webpage.\n\n\n**Scenario 3: Real-time Game Development with LLM Agents**\n\nIn a real-time game, LLM-powered agents can control non-player characters (NPCs). LSRP can be adapted to manage their actions:\n\n* **Pathfinding and Collision Avoidance:** LSRP’s core functionality can be directly used for pathfinding and avoiding collisions between NPCs in the game world.\n\n* **Asynchronous Action Handling:**  Different NPCs might have different movement speeds and action durations. LSRP handles this inherent asynchronicity.\n\n* **JavaScript Libraries:** Libraries like Phaser or Babylon.js can be used for rendering and game logic.  LSRP logic can be integrated to control the NPC behavior.\n\n\n\n**Key JavaScript Concepts and Libraries:**\n\n* **`PriorityQueue`:**  For managing pending actions, sorted by time.\n* **Caching (e.g., using Maps or plain JavaScript objects):** To store planned future actions.\n* **Asynchronous Programming (Promises, Async/Await):** To manage the asynchronous nature of LLM actions.\n* **Web Workers:** To offload LLM processing to separate threads, improving UI responsiveness.\n* **Real-time Data Synchronization Libraries (e.g., Socket.IO, Yjs, ShareDB):** To manage shared state in multi-user applications.\n\n\n\n\nBy applying these concepts, JavaScript developers can use the insights from this paper to build more robust and efficient LLM-based multi-agent systems for web applications. The core idea is to adapt LSRP’s principles of loose synchronization, priority-based action planning, and conflict resolution to JavaScript and integrate them with suitable web technologies.",
  "pseudocode": "```javascript\n// Algorithm 1: LSRP, LSRP-SWAP (Main Algorithm)\n\nfunction lsrp(graph, starts, goals) {\n  let T = [0]; // Timestamps\n  let ST = [{ v: starts, tv: Array(starts.length).fill(0) }]; // Joint states\n  let cache = {}; // Cached actions\n  let priorities = initPriorities(starts.length); // Initialize priorities\n\n  while (T.length > 0) {\n    let sprev = ST[ST.length - 1];\n\n    if (allAgentsAtGoal(sprev, goals)) {\n      return postProcess(ST); // Extract paths from joint states\n    }\n\n    for (let i = 0; i < starts.length; i++) {\n      if (sprev.v[i] === goals[i]) {\n        priorities[i] = 0; // Reset priority for agents at goal\n      } else {\n        priorities[i]++; // Increment priority for other agents\n      }\n    }\n\n    let tmin = T.shift(); // Get and remove minimum timestamp\n    let Icurr = extractAgents(starts.length, tmin, sprev); // Agents to be planned\n\n    let tnext;\n    if (T.length > 0) {\n      tnext = T[0];\n    } else {\n      tnext = tmin + minDuration(starts.length, graph, sprev.v);\n    }\n\n    let snext = {v: [...sprev.v], tv: [...sprev.tv]};\n\n\n    for (let i of Icurr.sort((a, b) => priorities[b] - priorities[a])) { // Descending priority order\n      let cachedAction = cache[[sprev.v[i], i, tmin].toString()];\n\n      if (cachedAction) {\n        snext.v[i] = cachedAction.v;\n        snext.tv[i] = cachedAction.tv;\n      } else {\n        let result = asyPush(i, [], tmin, tnext, false, graph, sprev, snext, priorities, cache, goals);\n        //(or asyPushSwap(i, [], tmin, tnext, false, graph, sprev, snext, priorities, cache, goals)) for LSRP-SWAP\n\n        if (!result) return \"failure\"; // No solution found\n\n      }\n    }\n\n    ST.push(snext);\n\n    for(let i = 0; i < starts.length; i++) {\n      T.push(sprev.tv[i]);\n      T.sort((a,b) => a-b);\n    }\n\n  }\n\n  return \"failure\";\n}\n\n\n\n// Helper functions (placeholders for brevity)\n\nfunction initPriorities(numAgents) { /* ... */ }\nfunction allAgentsAtGoal(sprev, goals) { /* ... */ }\nfunction postProcess(ST) { /* ... */ }\nfunction extractAgents(numAgents, tmin, sprev) { /* ... */ }\nfunction minDuration(numAgents, graph, currentVertices) { /* ... */ }\n\n\n// Algorithm 2: ASY-PUSH (Recursive Function)\n\nfunction asyPush(i, ban, t, tnext, bp, graph, sprev, snext, priorities, cache, goals) {/* ... */ }\n\n// Algorithm 3: WAITANDMOVE (Helper Function for ASY-PUSH)\nfunction waitAndMove(i, v, twait, sprev, snext, cache) {/* ... */ }\n\n\n\n// Algorithm 4: SWAP-REQUIRED-POSSIBLE\nfunction swapRequiredPossible(i, v, Icurr, sprev, snext, goals) { /* ... */ }\n\n\n// Algorithm 5: SWAP-REQUIRED, SWAP-POSSIBLE\nfunction swapRequired(v1, v2, goals) { /* ... */ }\n\nfunction swapPossible(v1, v2, goals) { /* ... */ }\n\n\n```\n\n\n\n**Algorithm 1: LSRP/LSRP-SWAP (Main Algorithm)**\n\n* **Purpose:**  Finds collision-free paths for multiple agents in a graph, considering asynchronous actions (different movement durations).\n* **Explanation:** This is the core algorithm that manages the search process. It uses a priority-based approach inspired by PIBT, but adapted for asynchronous actions using timestamps and a caching mechanism. The algorithm iteratively plans the next action for each agent, resolving conflicts by pushing lower-priority agents. LSRP-SWAP adds a swap operation for increased flexibility in certain graph topologies.\n\n\n**Algorithm 2: ASY-PUSH (Recursive Function)**\n\n* **Purpose:** Plans the next action for a given agent, considering potential conflicts and pushing other agents if necessary.\n* **Explanation:** This is a recursive function called by LSRP/LSRP-SWAP to plan an individual agent's movement. It tries to move the agent to the closest available vertex towards its goal.  If a vertex is occupied by another agent, it recursively calls ASY-PUSH for the blocking agent to try to move it out of the way (push operation).\n\n\n**Algorithm 3: WAITANDMOVE (Helper Function)**\n\n* **Purpose:** Inserts wait and move actions for an agent into the cache.\n* **Explanation:** This function is called by ASY-PUSH to record the agent's actions. It creates entries in the `cache` to store the agent's planned movements. This cache is used to avoid redundant planning.\n\n\n\n**Algorithm 4 & 5: SWAP-REQUIRED-POSSIBLE, SWAP-REQUIRED, SWAP-POSSIBLE**\n\n* **Purpose:**  These functions manage the swap operation in LSRP-SWAP.\n* **Explanation:**  These functions determine if and how a swap between two agents can be performed. SWAP-REQUIRED-POSSIBLE checks if a swap is beneficial and feasible. SWAP-REQUIRED and SWAP-POSSIBLE determine if a swap can be accomplished through pushes or pulls, respectively.  These operations are essential for solving instances where a simple push operation is insufficient, such as in the case illustrated in Figure 8 of the paper.\n\n\nThe provided JavaScript code is a structural representation of the pseudocode from the paper. Completing the placeholder helper functions and the core logic within `asyPush`, `swapRequiredPossible`, `swapRequired`, and `swapPossible` would create a fully functional implementation of the LSRP and LSRP-SWAP algorithms.  This requires careful consideration of the graph representation, conflict detection logic, and the details of the push, pull, and swap operations.",
  "simpleQuestion": "How can I scale asynchronous multi-agent pathfinding?",
  "timestamp": "2024-12-17T06:05:47.062Z"
}