{
  "arxivId": "2408.16462",
  "title": "Consensus Planning with Primal, Dual, and Proximal Agents \n",
  "abstract": "Consensus planning is a method for coordinating decision making across complex systems and organizations, including complex supply chain optimization pipelines. It arises when large interdependent distributed agents (systems) share common resources and must act in order to achieve a joint goal. In this paper, we introduce a generic Consensus Planning Protocol (CPP) to solve such problems. Our protocol allows for different agents to interact with the coordinating algorithm in different ways (e.g., as a primal or dual or proximal agent). In prior consensus planning work, all agents have been assumed to have the same interaction pattern (e.g., all dual agents or all primal agents or all proximal agents), most commonly using the Alternating Direction Method of Multipliers (ADMM) as proximal agents. However, this is often not a valid assumption in practice, where agents consist of large complex systems, and where we might not have the luxury of modifying these large complex systems at will. Our generic CPP allows for any mix of agents by combining ADMM-like updates for the proximal agents, dual ascent updates for the dual agents, and linearized ADMM updates for the primal agents. We prove convergence results for the generic CPP, namely a sublinear O(1/k) convergence rate under mild assumptions, and two-step linear convergence under stronger assumptions. We also discuss enhancements to the basic method and provide illustrative empirical results. \n",
  "summary": "- This paper introduces a new algorithm for coordinating decision-making across multiple AI agents that need to work together to solve a problem, even when those agents have different ways of communicating.\n- The key takeaway for LLM-based multi-agent systems is that this algorithm enables coordination between large language models and other AI systems, regardless of their specific design or existing implementation, without requiring costly re-writes. This is especially relevant for integrating LLMs into complex applications where different AI components may already be in place. \n",
  "takeaways": "## Practical Examples of LLM-based Multi-agent AI in Web Development using JavaScript\n\nThis paper provides a framework for building multi-agent systems with diverse capabilities, which is crucial when integrating LLMs that have different strengths and communication protocols. Here are some examples of how a JavaScript developer can apply these insights:\n\n**1. Collaborative Content Creation Platform**\n\n* **Scenario:** Imagine building a platform where multiple users (clients) can collaborate on writing a story. Each user acts as an agent with its own LLM specializing in different aspects of storytelling (e.g., dialogue, world-building, plot). \n* **Implementation:**\n    * **Agents:** Each user interacts with the platform through a web interface built with React or Vue.js. Each agent uses a dedicated LLM API (e.g., OpenAI, Cohere).\n    * **Coordination:** The 3ACP algorithm manages the consensus planning. A central server handles the coordinator role, receiving updates from each agent (user's LLM) and updating the shared story draft.\n    * **Diverse Agent Types:**\n        * **Primal Agents:** Some agents might be optimized for generating text given prompts (primal), returning the cost of deviating from the suggested text.\n        * **Dual Agents:** Other agents might excel at refining existing text based on feedback (dual), returning a revised draft.\n        * **Proximal Agents:** Some LLMs might be adaptable to both generating and refining, acting as proximal agents.\n    * **Benefits:** This approach allows for real-time, collaborative storytelling where diverse LLMs contribute their specialized skills.\n\n**2. AI-Powered Customer Service Chatbots**\n\n* **Scenario:** Develop a customer service system with multiple specialized chatbots. Each chatbot is an agent powered by an LLM trained on specific product knowledge bases, FAQs, or support tickets.\n* **Implementation:**\n    * **Agents:** Each chatbot interacts with customers via web chat widgets built with frameworks like Botkit or Dialogflow.\n    * **Coordination:** The 3ACP algorithm ensures a seamless handover between agents. The coordinator tracks customer requests and assigns them to the most relevant chatbot based on their expertise.\n    * **Diverse Agent Types:**\n        * **Primal Agents:**  A general-purpose chatbot (primal) could handle initial greetings and basic queries.\n        * **Dual Agents:** Specialized chatbots (dual) could address specific product issues based on pricing information or technical documentation.\n        * **Proximal Agents:** LLMs capable of handling both basic and advanced queries could dynamically adjust their behavior.\n    * **Benefits:**  This system provides efficient and accurate support by routing customer queries to the most knowledgeable chatbot.\n\n**3. Personalized E-commerce Recommendation Engine**\n\n* **Scenario:**  Create an e-commerce website where product recommendations are generated by a team of AI agents. Each agent specializes in analyzing different aspects of user behavior (browsing history, purchase history, wishlists).\n* **Implementation:**\n    * **Agents:** Each agent runs on a server, continuously analyzing user data and interacting with recommendation APIs.\n    * **Coordination:** The 3ACP algorithm combines individual agent recommendations to create a unified, personalized experience.\n    * **Diverse Agent Types:**\n        * **Primal Agents:**  Some agents could focus on suggesting trending or newly released products (primal).\n        * **Dual Agents:**  Others could specialize in finding complementary items based on cart contents or past purchases (dual).\n        * **Proximal Agents:** Some LLMs might excel at understanding user preferences from diverse signals like reviews and social media activity.\n    * **Benefits:**  This system delivers highly targeted product recommendations, enhancing user experience and potentially increasing sales.\n\n**JavaScript Frameworks and Libraries:**\n\n* **TensorFlow.js:** Enables running machine learning models in the browser, allowing for client-side agent implementation.\n* **WebSockets:** Facilitates real-time communication between agents and the coordinator.\n* **Node.js:** Provides a server-side environment for running the coordinator and coordinating agent interactions.\n\n**Key takeaways for JavaScript developers:**\n\n* **Modularity:**  3ACP allows integrating different LLMs without modifying their core functionality.\n* **Scalability:** The algorithm is designed for distributed systems, making it suitable for complex web applications.\n* **Efficiency:**  By leveraging specialized LLMs, developers can create more efficient and responsive multi-agent systems.\n\nThis approach bridges the gap between LLM research and real-world web development, empowering JavaScript developers to build innovative and intelligent multi-agent applications. \n",
  "pseudocode": "```javascript\nfunction vanilla3AgentCP(agents, initialPrices, tolerance = 1e-6) {\n  // Initialize parameters\n  let p = []; // Learning rates for each agent\n  for (let i = 0; i < agents.length; i++) {\n    p[i] = agents[i].type === 'dual' ? \n            agents[i].strongConvexityParameter : \n            (agents[i].type === 'primal' ? \n              agents[i].lipschitzConstant : \n              1); \n  }\n  let z = 0; // Initial consensus plan (can be initialized differently)\n  let lambda = [...initialPrices]; // Array of initial prices for each agent\n\n  // Check for valid initial prices: sum should be zero\n  if (lambda.reduce((sum, val) => sum + val, 0) !== 0) {\n    throw new Error(\"Invalid initial prices: sum must be zero.\");\n  }\n\n  // Main loop\n  let iteration = 0;\n  while (true) {\n    // 1. Agent updates\n    let x = agents.map((agent, i) => {\n      if (agent.type === 'primal') {\n        let gradient = agent.getGradient(z); \n        return (agent.lipschitzConstant * agent.plan + p[i] * z - gradient) / \n               (agent.lipschitzConstant + p[i]);\n      } else if (agent.type === 'dual') {\n        return agent.getPlan(lambda[i]);\n      } else { // proximal\n        return agent.getPlan(lambda[i], z, p[i]);\n      }\n    });\n\n    // 2. Consensus update\n    z = x.map((xi, i) => xi * p[i]).reduce((sum, val) => sum + val, 0) / \n        p.reduce((sum, val) => sum + val, 0);\n\n    // 3. Price updates\n    lambda = lambda.map((li, i) => li + p[i] * (z - x[i]));\n\n    // Convergence check (simplified example, replace with your criterion)\n    let maxDiff = Math.max(...lambda.map(Math.abs));\n    if (maxDiff < tolerance) {\n      break;\n    }\n\n    iteration++;\n  }\n\n  console.log(`Converged in ${iteration} iterations.`);\n  return z;\n}\n\n// Example agent definitions\nconst agents = [\n  { type: 'primal', lipschitzConstant: 2, plan: 1, getGradient: (z) => 2*z + 1 },\n  { type: 'dual', strongConvexityParameter: 1, getPlan: (l) => -l + 2 },\n  { type: 'proximal', getPlan: (l, z, p) => (p * z + l) / (1 + p) },\n];\n\n// Example usage with initial prices summing up to zero\nconst consensusPlan = vanilla3AgentCP(agents, [1, -0.5, -0.5]);\nconsole.log(\"Consensus Plan:\", consensusPlan); \n```\n\n**Explanation:**\n\nThis JavaScript code implements the 3-Agent Consensus Planning (3ACP) algorithm as described in the research paper. \n\n**Algorithm Purpose:**\n\nThe 3ACP algorithm aims to find a consensus plan ('z') among multiple agents who have potentially different ways of interacting with the system. These agents can be:\n\n* **Primal:** Provide the gradient of their objective function at a given plan.\n* **Dual:** Provide a preferred plan given a price.\n* **Proximal:**  Provide an updated plan given both a price and a tentative plan.\n\nThe algorithm iteratively updates the plans of individual agents, the global consensus plan, and the prices (dual variables) to converge towards an optimal and agreeable solution for all agents.\n\n**JavaScript Implementation Details:**\n\n1. **`vanilla3AgentCP(agents, initialPrices, tolerance)` Function:**\n   - Takes an array of `agents`, their `initialPrices`, and a `tolerance` level as input.\n   - Initializes learning rates (`p`) for each agent based on their type and provided parameters. \n   - Initializes the consensus plan (`z`) and an array of price variables (`lambda`).\n   - Enters a loop that continues until convergence is reached.\n\n2. **Within the Loop:**\n   - **Agent Updates:**\n     - For each agent, it updates its individual plan (`x[i]`) based on its type using the provided formulas:\n       - `primal`: Updates using the agent's gradient, Lipschitz constant, and the current consensus plan.\n       - `dual`: Updates by querying the agent's preferred plan given the current price.\n       - `proximal`: Updates using the provided formula for proximal agents.\n   - **Consensus Update:**\n     - Calculates a weighted average of the updated individual plans to determine the new consensus plan (`z`).\n   - **Price Update:**\n     - Updates the price variables (`lambda`) for each agent based on the difference between the consensus plan and the agent's updated plan.\n   - **Convergence Check:**\n     - The code includes a simplified convergence check using the maximum absolute difference in prices. In a real application, you would replace this with a more robust convergence criterion based on the problem's specifics.\n\n3. **Output:**\n   - The function returns the final consensus plan (`z`) after convergence.\n\n**Example Usage:**\n\n- The code defines an example array of `agents`, each with its type, parameters, and methods (e.g., `getGradient`, `getPlan`).\n- It then calls the `vanilla3AgentCP` function with the agents and initial prices to find the consensus plan.\n\nThis example demonstrates how you can implement the 3ACP algorithm in JavaScript to solve consensus-based optimization problems with diverse agents. Remember that this is a basic implementation, and you can extend it further by incorporating acceleration techniques, more robust convergence criteria, and handling of different agent behaviors. \n",
  "simpleQuestion": "How can LLM agents with different roles collaborate for efficient planning? \n",
  "timestamp": "2024-08-30T07:02:08.060Z"
}