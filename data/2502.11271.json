{
  "arxivId": "2502.11271",
  "title": "OctoTools: An Agentic Framework with Extensible Tools for Complex Reasoning",
  "abstract": "Solving complex reasoning tasks may involve visual understanding, domain knowledge retrieval, numerical calculation, and multi-step reasoning. Existing methods augment large language models (LLMs) with external tools but are restricted to specialized domains, limited tool types, or require additional training data. In this paper, we introduce OctoTools, a training-free, user-friendly, and easily extensible open-source agentic framework designed to tackle complex reasoning across diverse domains. OctoTools introduces standardized tool cards to encapsulate tool functionality, a planner for both high-level and low-level planning, and an executor to carry out tool usage. We validate OctoTools' generality across 16 diverse tasks (including MathVista, MMLU-Pro, MedQA, and GAIA-Text), achieving substantial average accuracy gains of 9.3% over GPT-40. Furthermore, OctoTools outperforms AutoGen, GPT-Functions and LangChain by up to 10.6% when given the same set of tools. Through comprehensive analysis and ablations, OctoTools demonstrates advantages in task planning, effective tool usage, and multi-step problem solving.",
  "summary": "OctoTools is a framework that allows Large Language Models (LLMs) to use external tools (like web search, calculators, or specialized code) for complex reasoning tasks without requiring retraining or fine-tuning.\n\nKey points for LLM-based multi-agent systems:\n\n* **Tool Cards:** Standardize how tools are integrated, making it easy to add, replace, or update tools.\n* **Planner:**  Orchestrates high-level (overall task) and low-level (individual step) plans for tool usage.\n* **Executor:** Converts planned actions into executable commands and manages tool execution.\n* **Toolset Optimization:**  Selects the most beneficial subset of tools for a given task, improving efficiency and accuracy.\n* **Multi-step Reasoning:** Enables LLMs to solve complex problems by breaking them down into smaller, manageable steps and using tools at each step.\n* **Training-Free:** No need to retrain or fine-tune the underlying LLM.\n* **Extensible:** Easily adaptable to new domains and tool types.",
  "takeaways": "This paper presents OctoTools, a framework for building LLM-powered multi-agent systems that can leverage external tools. Here's how a JavaScript developer can apply its core concepts to web development:\n\n**1. Tool Cards (Standardized Tool Interfaces):**\n\n* **Concept:** OctoTools uses \"tool cards\" to abstract away the specifics of each tool, providing a standardized interface for the LLM agent to interact with. This enables easy integration of new tools and promotes modularity.\n* **JavaScript Implementation:** Create JavaScript classes or objects representing each tool. These \"tool objects\" should have consistent methods like `execute(input)` which returns a structured result (e.g., a JSON object). This aligns with OctoTools' `execute()` function in tool cards.  You could use TypeScript interfaces to enforce this standardization.\n\n```javascript\n// Example Tool Object for a Web Search\nclass WebSearchTool {\n  async execute(query) {\n    const results = await fetch(`https://api.example.com/search?q=${query}`);\n    const json = await results.json();\n    return { urls: json.results, snippets: json.snippets }; // Structured result\n  }\n}\n\n// Example Tool Object for DOM Manipulation\nclass DomTool {\n  execute(selector, action, value) {\n    const element = document.querySelector(selector);\n    if (action === 'setText') {\n      element.textContent = value;\n      return { status: 'success', message: 'Text set' }; // Structured result\n    }\n     // ... other DOM actions\n  }\n}\n```\n\n**2. Planner (Task Decomposition & Tool Selection):**\n\n* **Concept:** The planner decides which tool to use and what sub-goal to pursue at each step, based on the current context.\n* **JavaScript Implementation:** Implement the planner logic using JavaScript.  Consider using a state machine library like `xstate` to manage the agent's workflow. The state machine transitions would represent the planner's decisions about which tool to invoke next.  For tool selection, you could implement a simple rule-based system or explore more advanced techniques like reinforcement learning (using libraries like `reinforcejs` for simpler exploration) to learn which tool works best in different situations.\n\n```javascript\n// Simplified Planner Logic (Rule-based)\nfunction planner(context) {\n  if (context.needsWebData) {\n    return { tool: 'WebSearchTool', subGoal: 'Find info on X' };\n  } else if (context.needsDomUpdate) {\n    return { tool: 'DomTool', subGoal: 'Update element Y' };\n  }\n  // ... other rules\n}\n```\n\n**3. Executor (Tool Invocation and Context Management):**\n\n* **Concept:**  The executor takes the planner's output and executes the chosen tool.  It then updates the context with the results.\n* **JavaScript Implementation:**  This can be a simple function that takes the planner's output (tool and sub-goal), finds the corresponding tool object, and calls its `execute()` method.  Use a JavaScript object to manage the context, storing the query, intermediate results, and the history of actions taken.\n\n```javascript\n// Simplified Executor Logic\nasync function executor(plannerOutput, context) {\n    const tool = getToolObject(plannerOutput.tool); // Retrieve tool object\n    const result = await tool.execute(plannerOutput.subGoal, context);\n    context.results.push(result); // Update the context\n    return context;\n}\n```\n\n**4. Toolset Optimization (Dynamic Tool Selection):**\n\n* **Concept:** OctoTools dynamically selects an optimal subset of tools for specific tasks.\n* **JavaScript Implementation:** Experiment with different combinations of tools for a given task and evaluate their performance. You could use A/B testing or other evaluation metrics to determine which toolset performs best.  Store the optimal toolset configuration in a JSON file or database and load it dynamically.\n\n\n**Web Development Scenarios:**\n\n* **Interactive Chatbots:** Build chatbots that can interact with the web page on behalf of the user (e.g., filling out forms, retrieving information, making reservations).\n* **Automated Content Creation:** Develop tools that automatically generate or curate content for websites by leveraging various tools (web scraping, image search, text summarization).\n* **Personalized User Interfaces:** Create dynamic and personalized web interfaces that adapt to user behavior and preferences by using tools to modify the DOM, retrieve user data, and provide recommendations.\n\n**JavaScript Frameworks/Libraries:**\n\n* `xstate`: For managing the agent's workflow.\n* `LangChainJS`: For connecting LLMs and chains of operations, although OctoTools' concept suggests building a custom solution for deeper control.\n* `TensorFlow.js`/`Brain.js`: If exploring more advanced tool selection methods like reinforcement learning.\n* Various web scraping libraries: For building tools that retrieve data from websites.\n\nBy implementing these concepts, JavaScript developers can build sophisticated, modular, and adaptable LLM-based multi-agent systems for a variety of web development applications.  Start with simple scenarios and progressively incorporate more advanced techniques as needed. Remember that this framework is meant to inspire; adapt it based on your needs.",
  "pseudocode": "```javascript\nfunction taskSpecificToolsetOptimization(toolbox, baseToolset) {\n  // Stage 1: Baseline setup\n  const accBaseline = calculateAccuracy(baseToolset);\n\n  // Stage 2: Individual tool evaluation\n  let beneficialTools = [];\n  for (const tool of toolbox) {\n    if (!baseToolset.includes(tool)) {\n      const augmentedToolset = [...baseToolset, tool];\n      const accTool = calculateAccuracy(augmentedToolset);\n      const deltaAcc = accTool - accBaseline;\n      if (deltaAcc > 0) {\n        beneficialTools.push(tool);\n      }\n    }\n  }\n\n  // Stage 3: Select optimized toolset\n  const optimizedToolset = [...beneficialTools, ...baseToolset];\n  return optimizedToolset;\n}\n\n\n// Helper function to simulate calculating accuracy \n// (replace with actual evaluation logic in a real implementation)\nfunction calculateAccuracy(toolset) {\n  // Placeholder: In a real application, this would involve running the agent\n  // with the given toolset on a validation set and measuring its accuracy.\n  // For this example, we return a random number to simulate varying accuracy.\n  return Math.random() * 20 + 40; // Accuracy between 40% and 60%\n}\n\n// Example usage:\nconst toolbox = [\"ToolA\", \"ToolB\", \"ToolC\", \"ToolD\", \"ToolE\"];\nconst baseToolset = [\"ToolA\", \"ToolB\"]; \nconst optimizedSet = taskSpecificToolsetOptimization(toolbox, baseToolset);\nconsole.log(\"Optimized Toolset:\", optimizedSet); \n\n```\n\n**Algorithm 1: Task-specific Toolset Optimization**\n\nThis algorithm aims to select the most beneficial subset of tools from a larger toolbox for a specific task, given a base toolset and a set of validation examples. It uses a greedy approach to avoid the exponential complexity of evaluating all possible tool combinations.\n\n**Purpose:**  Improve agent performance and efficiency by identifying the most relevant tools for a given task, preventing noise introduced by less helpful tools.\n\n**Explanation:**\n\n1. **Baseline Setup:** Establishes a baseline performance using only the `baseToolset`.  This `baseToolset` represents essential tools and could be pre-defined or empty.  The `calculateAccuracy` function (which is a placeholder in this example and needs to be implemented with actual agent evaluation logic) is called to get the baseline accuracy.\n\n2. **Individual Tool Evaluation:** Iterates through the remaining tools in the `toolbox` (excluding those already present in the `baseToolset`). For each tool, it creates a temporary toolset by adding the tool to the `baseToolset`, calculates the accuracy of the agent with this augmented toolset, and calculates the improvement in accuracy (`deltaAcc`) compared to the baseline. If the tool improves accuracy (`deltaAcc > 0`), it is added to the list of `beneficialTools`.\n\n3. **Optimized Toolset Selection:** Combines the `beneficialTools` with the `baseToolset` to create the `optimizedToolset`. This final toolset contains the tools that individually demonstrated a performance gain over the baseline.\n\n**Key Improvements over Exhaustive Search:** The greedy approach makes toolset optimization feasible for larger toolboxes by evaluating only *n* potential toolsets (where *n* is the number of tools) instead of all 2<sup>*n*</sup> combinations. While this doesn't guarantee a globally optimal toolset, it provides a practical and efficient solution for improving agent performance.",
  "simpleQuestion": "How can I build better LLM agents with tools?",
  "timestamp": "2025-02-18T06:04:10.284Z"
}