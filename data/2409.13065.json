{
  "arxivId": "2409.13065",
  "title": "Multi-Agent Vulcan: An Information-Driven Multi-Agent Path Finding Approach",
  "abstract": "Abstract-Scientists often search for phenomenon of interest while exploring new environments. Autonomous vehicles are deployed to explore such areas where human-operated vehicles would be costly or dangerous. Online control of autonomous vehicles for information-gathering is called adaptive sampling and can be framed as a Partially Observable Markov Decision Process (POMDPs) that uses information gain as its principal objective. While prior work focuses largely on single-agent scenarios, this paper confronts challenges unique to multi-agent adaptive sampling, such as avoiding redundant observations, preventing vehicle collision, and facilitating path planning under limited communication. We start with Multi-Agent Path Finding (MAPF) methods, which address collision avoidance by decomposing the multi-agent path planning problem into a series of single-agent path planning problems. We present an extension to these methods called information-driven MAPF which addresses multi-agent information gain under limited communication. First, we introduce an admissible heuristic that relaxes mutual information gain to an additive function that can be evaluated as a set of independent single agent path planning problems. Second, we extend our approach to a distributed system that is robust to limited communication. When all agents are in range, the group plans jointly to maximize information. When some agents move out of range, communicating subgroups are formed and the subgroups plan independently. Since redundant observations are less likely when vehicles are far apart, this approach only incurs a small loss in information gain, resulting in an approach that gracefully transitions from full to partial communication. We evaluate our method against other adaptive sampling strategies across various scenarios, including real-world robotic applications. Our method was able to locate up to 200% more unique phenomena in certain scenarios, and each agent located its first unique phenomenon faster by up to 50%.",
  "summary": "This paper introduces \"Multi-Agent Vulcan\", a system where multiple AI agents collaborate to efficiently explore an environment and identify \"phenomena of interest\" within a limited timeframe. \n\nKey points for LLM-based multi-agent systems:\n\n* **Information-driven approach:** Agents use a reward function based on \"mutual information gain\" to prioritize exploration of unseen areas and minimize redundant observations.\n* **Decoupled heuristic:** A computationally efficient heuristic based on single-agent exploration is used to guide the multi-agent planning process, reducing the need for complex reward calculations.\n* **Distributed execution:** The system can operate in a distributed manner, with agents planning independently when outside communication range and collaboratively when within range.",
  "takeaways": "This research paper presents exciting possibilities for JavaScript developers working with LLMs in multi-agent web applications. Let's break down how you can apply these concepts:\n\n**Scenario:** Imagine building a collaborative online game where multiple LLM-powered agents interact within a virtual world to complete tasks, similar to an AI-driven RPG. \n\n**JavaScript Implementation:**\n\n1. **Agent Communication (Bubbles):** The paper's \"communication bubbles\" concept can be implemented using web sockets.\n\n   ```javascript\n   // When agents are within range (e.g., same game zone)\n   const socket = new WebSocket('ws://your-server-address');\n\n   socket.onmessage = (event) => {\n       const data = JSON.parse(event.data); \n       // Update agents' knowledge based on received observations\n   };\n   ```\n\n2. **Decoupled Pathfinding:** Use a JavaScript pathfinding library like `PathFinding.js` or `Easystar.js`.  Each agent can independently calculate paths. When in a communication bubble, share observations to refine paths and avoid redundant exploration.\n\n   ```javascript\n   // Example using PathFinding.js\n   import { AStarFinder } from 'pathfinding';\n\n   const grid = new Grid(matrix); // Your game world grid\n   const finder = new AStarFinder();\n\n   function findPath(start, end) { \n       const path = finder.findPath(start.x, start.y, end.x, end.y, grid);\n       return path; \n   }\n   ```\n\n3. **Information-Driven Exploration:**  Implement the core idea of maximizing information gain.\n\n   * **Representing Knowledge:**  Use JavaScript objects to model each agent's beliefs about the game world (e.g., location of items, status of quests). \n   * **Information Gain Heuristic:**  While the paper's heuristic is complex, you can approximate it. For example, prioritize exploration of areas with the most uncertainty in the agent's knowledge.\n   * **LLM Integration:** Prompt your LLM to reason about the knowledge representation and help choose actions that maximize information gain.\n\n   ```javascript\n   // Example Prompt (using a hypothetical LLM API)\n   const llmResponse = await llm.generate({\n       prompt: `\n           You are an explorer.\n           Current knowledge: ${JSON.stringify(agentKnowledge)}\n           Available actions: move north, move east, examine area\n           Choose the action that will give you the most new information. \n       ` \n   });\n\n   // Parse the LLM's response and execute the chosen action\n   ```\n\n4. **Visualization:** Use a JavaScript library like `Phaser`, `PixiJS`, or `Three.js` to visualize your agents and the game world dynamically.\n\n**Key Advantages for JavaScript Developers:**\n\n* **Modularity:**  The decoupled nature of multi-agent systems aligns well with JavaScript's event-driven model.\n* **Web Technologies:** Web sockets provide efficient real-time communication. Client-side JavaScript is ideal for handling dynamic updates in the user interface.\n* **LLM Empowerment:** LLMs excel at handling natural language, making them well-suited for tasks like interpreting instructions, generating dialogue for agents, and strategizing based on complex information.\n\n**Challenges:**\n\n* **Efficient Heuristics:** Finding a good balance between computational efficiency and accurate information gain estimation will be crucial, especially for web-based games that require real-time performance.\n* **LLM Costs:** Repeatedly calling LLMs for decision-making can be computationally expensive. Explore techniques like caching and efficient prompt design.\n\nBy adapting the concepts from this paper, JavaScript developers can create highly engaging and intelligent multi-agent applications. The fusion of LLM capabilities with these AI principles opens up a new frontier for innovative web development.",
  "pseudocode": "```javascript\nfunction multiAgentSearch(agentBubble, environment) {\n  // Combine observations from all agents in the bubble.\n  const combinedObservations = agentBubble.map(agent => agent.observations).flat();\n  \n  // Create the initial state using combined observations.\n  let currentState = {\n    observations: combinedObservations,\n    featureProbabilities: calculateFeatureProbabilities(combinedObservations),\n    phenomenonProbabilities: calculatePhenomenonProbabilities(combinedObservations) \n  };\n\n  // Calculate g and h values for the initial state.\n  currentState.g = calculateInformationGain(currentState);\n  currentState.h = calculateHeuristic(currentState);\n\n  // Initialize the open list with the initial state.\n  const openList = [currentState]; \n\n  // Initialize variables for tracking the best information gain and actions.\n  let bestInformationGain = -Infinity; \n  let bestActions = [];\n\n  // Main loop of the A* search algorithm.\n  while (openList.length > 0) {\n    // Find the state with the highest f value in the open list.\n    const currentState = openList.reduce((bestState, state) => state.g + state.h > bestState.g + bestState.h ? state : bestState, openList[0]);\n    openList.splice(openList.indexOf(currentState), 1); \n\n    // If the current state's f value is less than the best information gain, stop searching.\n    if (currentState.g + currentState.h <= bestInformationGain) {\n      return bestActions;\n    }\n\n    // If the current state is at the planning horizon and its f value is greater than the best information gain, update the best information gain and actions.\n    if (currentState.timestep >= planningHorizon && currentState.g + currentState.h > bestInformationGain) {\n      bestInformationGain = currentState.g + currentState.h;\n      bestActions = currentState.actions;\n    } \n    \n    // If the current state is not at the planning horizon, expand it and evaluate its children.\n    else if (currentState.timestep < planningHorizon) {\n      // Generate all possible child states from the current state.\n      const children = generateChildren(currentState); \n\n      // Sort the children by their h value in descending order.\n      children.sort((a, b) => b.h - a.h); \n\n      for (const child of children) {\n        // If the child's optimistic f value is greater than the current best information gain, add it to the open list.\n        if (currentState.g + child.h > bestInformationGain) {\n          openList.push(child);\n        } else {\n          // Since children are sorted by h, if one child's f is less than bestInformationGain\n          // all subsequent children's f will also be less than bestInformationGain,\n          // therefore we can break out of the loop.\n          break; \n        }\n      }\n    }\n  }\n  // If no path to the goal is found, return the best actions found so far.\n  return bestActions; \n}\n\n// Placeholder functions to be implemented based on the research paper.\nfunction calculateFeatureProbabilities(observations) { /* ... */ }\nfunction calculatePhenomenonProbabilities(observations) { /* ... */ }\nfunction calculateInformationGain(state) { /* ... */ } \nfunction calculateHeuristic(state) { /* ... */ } \nfunction generateChildren(state) { /* ... */ } \n```\n\n**Explanation:**\n\nThe `multiAgentSearch` function implements a modified version of the A* search algorithm optimized for multi-agent pathfinding in an information-gathering context. Here's a breakdown:\n\n1. **Initialization:** The function takes a group of agents (`agentBubble`) within communication range and the `environment` as input. It combines their observations, calculates initial state probabilities, and initializes the A* search components like the `openList`, `bestInformationGain`, and `bestActions`.\n\n2. **State Evaluation and Expansion:** The algorithm iterates through potential states. It prioritizes states with higher `f` values (`f = g + h`, where `g` is the actual information gain and `h` is the heuristic estimate).\n\n3. **Heuristic Optimization:**  A key optimization is the use of a pre-computed optimistic heuristic (`h`) to prune the search space.  The algorithm avoids expanding states whose optimistic outcome (`g + h`) is still worse than the best information gain (`bestInformationGain`) achievable from an already explored state. This drastically reduces computation, especially in large search spaces.\n\n4. **Action Selection:** The algorithm continues exploring until no better paths can be found. It then returns the `bestActions` â€” the set of actions leading to the highest information gain found within the search.\n\n**Purpose:**\n\nThis algorithm aims to efficiently find optimal or near-optimal paths for a group of agents working together to maximize information gathered in an environment, even with limited communication. It achieves this by leveraging the principles of A* search, incorporating a domain-specific heuristic, and optimizing for computational efficiency in a multi-agent setting.",
  "simpleQuestion": "How to plan paths for multiple agents to find information?",
  "timestamp": "2024-09-23T05:01:16.283Z"
}