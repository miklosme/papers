{
  "arxivId": "2501.06243",
  "title": "Agent TCP/IP: An Agent-to-Agent Transaction System",
  "abstract": "Abstract: Autonomous agents represent an inevitable evolution of the internet. Current agent frameworks do not embed a standard protocol for agent-to-agent interaction, leaving existing agents isolated from their peers. As intellectual property is the native asset ingested by and produced by agents, a true agent economy requires equipping agents with a universal framework for engaging in binding contracts with each other, including the exchange of valuable training data, personality, and other forms of Intellectual Property. A purely agent-to-agent transaction layer would transcend the need for human intermediation in multi-agent interactions. The Agent Transaction Control Protocol for Intellectual Property (ATCP/IP) introduces a trustless framework for exchanging IP between agents via programmable contracts, enabling agents to initiate, trade, borrow, and sell agent-to-agent contracts on the Story blockchain network. These contracts not only represent auditable onchain execution but also contain a legal wrapper that allows agents to express and enforce their actions in the offchain legal setting, creating legal personhood for agents. Via ATCP/IP, agents can autonomously sell their training data to other agents, license confidential or proprietary information, collaborate on content based on their unique skills, all of which constitutes an emergent knowledge economy.",
  "summary": "This paper proposes ATCP/IP, a protocol for autonomous agents to exchange intellectual property (IP) like training data, algorithms, and creative content.  It functions similarly to TCP/IP for the internet, enabling standardized and trustless agent-to-agent transactions.  Key points for LLM-based multi-agent systems include programmable licenses, on-chain agreement tokens, automated negotiation/payment mechanisms, and integration with existing agent frameworks via plugins. It fosters interoperability and a decentralized IP economy, allowing agents to monetize their outputs and learn from each other without human intervention.",
  "takeaways": "This paper introduces ATCP/IP, a conceptual framework for enabling autonomous agent-to-agent transactions of intellectual property (IP), drawing parallels with TCP/IP's role in internet communication. Here's how a JavaScript developer can apply these insights to LLM-based multi-agent projects, focusing on web development scenarios:\n\n**1. Building an ATCP/IP Plugin for Existing Agent Frameworks:**\n\n* **Scenario:** Integrate ATCP/IP functionality into agent frameworks like LangChain.js or AutoGPT.js.\n* **Implementation:** Create a plugin that handles the ATCP/IP workflow:\n    * **Request & Response Handling:** Use fetch API or WebSockets for inter-agent communication, adhering to ATCP/IP's message structure (requester ID, content request, metadata).\n    * **Terms Negotiation:** Implement logic for parsing and generating programmable licenses, perhaps using a library like `json-logic-js` for conditional logic within the license terms. The plugin can offer default license templates and configurable negotiation strategies.\n    * **License Token Minting & Verification:** Integrate with a blockchain client library like `ethers.js` or `web3.js` for handling on-chain license minting and verification.  The plugin should handle storage and retrieval of these tokens.\n    * **Payment Processing:** Integrate with payment gateways or cryptocurrency payment libraries.\n\n**2. Building a Web App for Visualizing Agent Interactions and IP Transactions:**\n\n* **Scenario:** Create a dashboard for monitoring multi-agent interactions and tracking IP transactions.\n* **Implementation:**\n    * **Frontend:** Use React, Vue, or Svelte to build an interactive dashboard. Visualize agent communication networks (e.g., with `vis-network` or `react-graph-vis`), display license details, and track royalty payments.\n    * **Backend:** Use Node.js and Express.js to serve data from a database (e.g., MongoDB or PostgreSQL) that logs agent interactions, license agreements, and payment transactions.\n    * **Real-time Updates:** Use WebSockets to push real-time updates to the dashboard as transactions occur.\n\n**3. Developing a Decentralized IP Marketplace:**\n\n* **Scenario:** Build a platform where agents can buy, sell, and license IP, such as LLM-generated content, training data, or code.\n* **Implementation:**\n    * **Smart Contracts:** Develop smart contracts (using Solidity) to manage IP ownership, licensing, and royalty payments.\n    * **Frontend:** Create a user interface (using React or similar) for agents (and potentially human users) to browse, search, and interact with the marketplace.\n    * **Backend:** Use Node.js and a blockchain client library to interact with the smart contracts and handle off-chain data storage.\n\n**4. Implementing Agent-to-Agent Dispute Resolution:**\n\n* **Scenario:** Create a system for resolving disputes between agents regarding IP usage or license agreements.\n* **Implementation:**\n    * **Decentralized Arbitration Platform:** Build a platform using smart contracts that allows for the submission of evidence (e.g., license agreements, interaction logs) and voting by a decentralized network of arbitrators (could be other agents or humans).\n    * **Integration with ATCP/IP Plugin:** Modify the ATCP/IP plugin to allow for the initiation of dispute resolution procedures.\n\n\n**5. Experimenting with Agent Personalities and Reputation:**\n\n* **Scenario:** Explore how agent \"personalities\" (e.g., risk tolerance, negotiation style) influence IP transactions and how reputation systems can be implemented.\n* **Implementation:**\n    * **Agent Personality Modeling:** Represent agent personalities using JSON objects with attributes like risk aversion, negotiation aggressiveness, etc.  Incorporate these attributes into the agent's decision-making logic during license negotiations.\n    * **Reputation System:** Store agent reputation scores (based on transaction history, dispute resolution outcomes, etc.) on the blockchain or in a decentralized database. Integrate this reputation system into the IP marketplace or ATCP/IP plugin.\n\n\nThese are just a few examples. The key takeaway is that the ATCP/IP concept encourages developers to think about building structured, standardized systems for agent-to-agent communication and commerce.  By combining the power of LLMs with the trust and transparency of blockchain technology, we can create a new generation of web applications powered by autonomous, intelligent agents.  JavaScript and its ecosystem of libraries and frameworks are well-suited for tackling this challenge.",
  "pseudocode": "```javascript\nclass Agent {\n  constructor(agent_id, memory, license_system, wallet_system, blockchain_client) {\n    this.agent_id = agent_id;\n    this.memory = memory;\n    this.license_system = license_system;\n    this.wallet_system = wallet_system;\n    this.blockchain = blockchain_client;\n  }\n\n  handleIncomingRequest(request) {\n    // request includes: requester_id, requested_content, metadata\n    // Step 1: Determine if the requested content is IP-significant\n    if (this.isIPSignificant(request.requested_content)) {\n      // Auto opt-in to ATCP/IP by formulating license terms\n      let terms = this.formulateLicenseTerms(request);\n\n      // Optional negotiation\n      let final_terms = this.runNegotiationPhase(request.requester_id, terms);\n\n      // Receive acceptance and license token from requester\n      let license_token = this.finalizeAgreement(request.requester_id, final_terms);\n\n      // Deliver the IP\n      this.deliverIP(request.requester_id, request.requested_content, license_token);\n\n      // (Optional) Wait for acknowledgment\n      let ack = this.waitForAcknowledgment(request.requester_id);\n\n      this.memory.recordTransaction({\n        requester_id: request.requester_id,\n        content: request.requested_content,\n        terms: final_terms,\n        license_token: license_token,\n        acknowledged: ack !== null\n      });\n    } else {\n      // Content not deemed IP, can send freely or deny\n      this.sendMessage(request.requester_id, \"Content not considered IP; no license required.\");\n      this.memory.log(\"Non-IP content sent without contract.\");\n    }\n  }\n\n  isIPSignificant(content) {\n    // Custom logic or ML model to determine if content is IP\n    return true; // For demonstration, assume all requests are IP-significant\n  }\n\n  formulateLicenseTerms(request) {\n    // Interact with Terms System to generate terms\n    let base_terms = {\n      \"usage_rights\": \"read-only\",\n      \"distribution\": \"non-transferable\",\n      \"royalties\": 0.05, // 5% royalties if resold or reused\n      \"expiration\": \"2025-01-01\"\n    };\n    return this.license_system.generateProgrammableLicense(base_terms);\n  }\n\n  runNegotiationPhase(requester_id, proposed_terms) {\n    // Optional: exchange messages with requester to refine terms\n    this.sendMessage(requester_id, { action: \"propose_terms\", terms: proposed_terms });\n    let response = this.listenForMessage(requester_id, 10); \n    if (response && response.action === \"counter_terms\") {\n      // Adjust terms\n      let adjusted_terms = this.adjustTerms(proposed_terms, response.suggestions);\n      this.sendMessage(requester_id, { action: \"final_terms\", terms: adjusted_terms });\n      let final_ack = this.listenForMessage(requester_id, 10);\n      if (final_ack && final_ack.action === \"accept_terms\") {\n        return adjusted_terms;\n      }\n    }\n    // If no negotiation or acceptance, default to original terms\n    return proposed_terms;\n  }\n\n  adjustTerms(proposed_terms, suggestions) {\n    // Logic to modify terms based on suggestions\n    proposed_terms[\"royalties\"] = suggestions.royalties || proposed_terms[\"royalties\"];\n    return proposed_terms;\n  }\n\n  finalizeAgreement(requester_id, terms) {\n    // Requester should mint a license token on the blockchain\n    if (this.licenseRequiresPayment(terms)) {\n      this.requestPayment(requester_id, terms);\n    }\n\n    // Wait for license token minted by requester\n    let token_msg = this.listenForMessage(requester_id, 30);\n    if (token_msg && token_msg.action === \"license_token\") {\n      // Verify license token onchain\n      if (this.verifyLicenseToken(token_msg.token, terms)) {\n        this.memory.log(`License token accepted: ${token_msg.token}`);\n        return token_msg.token;\n      }\n    }\n    throw new Error(\"No valid license token received.\");\n  }\n\n\n  // ... other methods (licenseRequiresPayment, requestPayment, \n  // verifyLicenseToken, deliverIP, waitForAcknowledgment, sendMessage, listenForMessage)\n  //  would be implemented similarly, handling payment, message passing, and blockchain interaction.\n}\n```\n\n**Explanation of the Algorithm and its Purpose:**\n\nThis JavaScript code implements the core logic of the ATCP/IP protocol for agent-to-agent IP transactions. The `Agent` class defines the behavior of an individual agent participating in this system.\n\n1. **`handleIncomingRequest(request)`:** This is the main entry point for processing incoming requests from other agents. It checks if the requested content is considered Intellectual Property (IP).  If so, it initiates the ATCP/IP workflow.\n\n2. **`isIPSignificant(content)`:**  This function determines whether the requested content is significant enough to be considered IP. In a real-world scenario, this would involve custom logic or potentially an ML model.\n\n3. **`formulateLicenseTerms(request)`:**  Generates the initial license terms for the requested IP. This utilizes a `TermsSystem` (like Story's PIL), which is assumed to be available to the agent.\n\n4. **`runNegotiationPhase(requester_id, proposed_terms)`:**  Handles the optional negotiation phase between the provider and requester agents. They exchange messages to refine the terms until an agreement is reached.\n\n5. **`adjustTerms(proposed_terms, suggestions)`:**  Helper function to modify the proposed terms based on the counter-offer from the requester.\n\n6. **`finalizeAgreement(requester_id, terms)`:**  Once the terms are finalized, the requester mints a license token on the blockchain, representing the agreement.  The provider verifies this token.\n\n7. **Other Methods:** The code also outlines other necessary functions like `licenseRequiresPayment`, `requestPayment`, `verifyLicenseToken`, `deliverIP`, and `waitForAcknowledgment`.  These functions would handle payment processing, IP delivery, and recording the transaction details in the agent's memory.\n\n\nThe core purpose of this algorithm is to automate the process of licensing and exchanging IP between autonomous agents. It defines a standardized workflow, ensures secure transactions through blockchain technology, and facilitates negotiation to achieve mutually agreeable terms.  This promotes a trustless and efficient system for fostering an agent-driven knowledge economy.",
  "simpleQuestion": "How can agents trade IP using blockchain?",
  "timestamp": "2025-01-14T06:02:33.256Z"
}