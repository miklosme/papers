{
  "arxivId": "2503.15204",
  "title": "WHEN PIGS GET SICK: MULTI-AGENT AI FOR SWINE DISEASE DETECTION",
  "abstract": "Swine disease surveillance is critical to the sustainability of global agriculture, yet its effectiveness is frequently undermined by limited veterinary resources, delayed identification of cases, and variability in diagnostic accuracy. To overcome these barriers, we introduce a novel AI-powered, multi-agent diagnostic system that leverages Retrieval-Augmented Generation (RAG) to deliver timely, evidence-based disease detection and clinical guidance. By automatically classifying user inputs into either Knowledge Retrieval Queries or Symptom-Based Diagnostic Queries, the system ensures targeted information retrieval and facilitates precise diagnostic reasoning. An adaptive questioning protocol systematically collects relevant clinical signs, while a confidence-weighted decision fusion mechanism integrates multiple diagnostic hypotheses to generate robust disease predictions and treatment recommendations. Comprehensive evaluations encompassing query classification, disease diagnosis, and knowledge retrieval demonstrate that the system achieves high accuracy, rapid response times, and consistent reliability. By providing a scalable, AI-driven diagnostic framework, this approach enhances veterinary decision-making, advances sustainable livestock management practices, and contributes substantively to the realization of global food security.",
  "summary": "This paper introduces a multi-agent AI system for diagnosing swine diseases. It uses a retrieval-augmented generation (RAG) approach to provide timely and evidence-based diagnoses and treatment recommendations.  The system classifies user queries, gathers symptoms via an adaptive questioning protocol, uses multiple specialized diagnostic agents, and fuses their predictions with a confidence-weighted mechanism.\n\nKey LLM-based multi-agent aspects include: specialized agents for different diseases, RAG for retrieving relevant information from a veterinary knowledge base, adaptive questioning to refine diagnostic accuracy, and an iterative refinement process for generating robust recommendations. The system demonstrates the potential of multi-agent architectures and LLMs for complex decision-making in veterinary diagnostics.",
  "takeaways": "This paper presents valuable insights for JavaScript developers working on LLM-based multi-agent applications, particularly in web development. Here's how developers can apply these insights, illustrated with practical examples and relevant JavaScript tools:\n\n**1. Query Classification & Routing:**\n\n* **Concept:** Categorizing user input to direct it to the appropriate agent or service.\n* **JavaScript Implementation:**\n    * Use a natural language processing (NLP) library like Compromise, Natural, or a cloud-based NLP API to analyze user input.\n    * Create a routing function that classifies the intent of the user's query (e.g., information retrieval, diagnosis, clarification needed).\n    * Based on the classification, route the query to the appropriate agent (e.g., a knowledge retrieval agent using LangChain, a diagnostic agent using a custom LLM interface, or a clarification request handler).\n* **Example:**\n\n```javascript\n// Using Compromise for basic NLP\nconst nlp = require('compromise');\n\nfunction routeQuery(query) {\n  const doc = nlp(query);\n  if (doc.has('#Question')) { // Simple question detection\n    return 'knowledgeRetrievalAgent';\n  } else if (doc.has('#Symptom')) { //  Need more sophisticated symptom detection\n    return 'diagnosticAgent';\n  } else {\n    return 'clarificationAgent';\n  }\n}\n\nconst userQuery = \"My pig has a fever and is lethargic.\";\nconst agent = routeQuery(userQuery);\nconsole.log(`Routing to: ${agent}`); // Output: Routing to: diagnosticAgent\n```\n\n**2. Multi-Agent Disease Prediction:**\n\n* **Concept:**  Using multiple specialized LLMs (agents) to collaboratively diagnose potential diseases based on user-provided symptoms.\n* **JavaScript Implementation:**\n    * Develop or utilize separate LLM interfaces for each disease specialist agent, potentially encapsulating them as JavaScript classes.\n    * Implement a \"confidence-weighted decision fusion\" mechanism.  This could involve averaging the confidence scores from each agent, weighted by their pre-determined expertise level.\n    * Use a library like TensorFlow.js or Brain.js if you want to train a separate model for confidence score fusion.\n* **Example (Conceptual):**\n\n```javascript\n// Assume 'asfAgent', 'prrsAgent', 'pedAgent' are instances of LLM interfaces\nconst agents = [asfAgent, prrsAgent, pedAgent];\nconst weights = [0.8, 0.7, 0.9]; // Expertise weights\n\nfunction diagnose(symptoms) {\n    const diagnoses = agents.map((agent, index) => ({\n        disease: agent.diagnose(symptoms), \n        confidence: agent.confidence * weights[index]\n    }));\n\n    // Sort by confidence and return top diagnosis\n    return diagnoses.sort((a, b) => b.confidence - a.confidence)[0];\n}\n```\n\n**3. Recommendations using RAG:**\n\n* **Concept:** Providing contextually appropriate advice using a Retrieval Augmented Generation (RAG) approach, combining LLM-generated advice with retrieved relevant information.\n* **JavaScript Implementation:**\n    * Integrate LangChain or LlamaIndex.js with your LLM interface.\n    * Index your knowledge base (e.g., veterinary documents, research papers).\n    * Use the classified query and diagnosis to retrieve relevant documents.\n    * Pass the retrieved documents as context to the LLM to generate recommendations.\n* **Example (Conceptual - using LangChain):**\n\n```javascript\nconst { OpenAI } = require(\"langchain/llms/openai\");\nconst { loadSummarizationChain } = require(\"langchain/chains\");\nconst { RecursiveCharacterTextSplitter } = require(\"langchain/text_splitter\");\n// ... (Vectorstore setup for your knowledge base - Pinecone, FAISS, etc.)\n\nasync function getRecommendations(query, diagnosis, vectorstore) {\n  const llm = new OpenAI({ temperature: 0 });\n  const chain = loadSummarizationChain(llm, { type: \"map_reduce\" });\n  const relevantDocs = await vectorstore.similaritySearch(query + diagnosis, 3); // Get top 3 related documents\n  const splitter = new RecursiveCharacterTextSplitter({ chunkSize: 1000 });\n  const docs = await splitter.createDocuments(relevantDocs.map((doc) => doc.pageContent)); // Split long docs if needed.\n  const res = await chain.call({ input_documents: docs }); \n  return res.text;\n}\n\n```\n\n**4.  Adaptive Questioning:**\n\n* **Concept:** Dynamically request more information from the user based on their responses.\n* **JavaScript Implementation:**\n    * Design a state machine to manage the conversation flow (e.g., general symptoms -> specific symptoms -> diagnostic tests).\n    * Use JavaScript promises or async/await to handle asynchronous interactions with the user.\n* **Example (State Machine - Conceptual):**\n\n```javascript\nconst states = {\n  GENERAL: 'general',\n  SPECIFIC: 'specific',\n  DIAGNOSIS: 'diagnosis'\n};\n\nlet currentState = states.GENERAL;\n\nfunction getNextQuestion(userResponse) {\n  switch (currentState) {\n    case states.GENERAL:\n      // Analyze response, if needed, transition to SPECIFIC or DIAGNOSIS\n      // Return the appropriate question\n      break;\n    // ... other states\n  }\n}\n```\n\n\n\nThese examples show how to integrate the paper's multi-agent and RAG concepts using JavaScript and web technologies. Libraries like LangChain, LlamaIndex.js and NLP tools are crucial for building these systems. By combining these elements, JavaScript developers can create powerful multi-agent applications capable of sophisticated reasoning and information retrieval.  The emphasis on user experience, through clear query classification and adaptive questioning, is essential for building practical and user-friendly web-based AI systems.",
  "pseudocode": "No pseudocode block found. However, there are mathematical formulas and conceptual descriptions of algorithms that could be translated into JavaScript.  Let's convert some of the core algorithmic components described in the paper:\n\n**1. Confidence-Based Disease Prediction (Section 3.2.3):**\n\n```javascript\nfunction calculateConfidence(disease, agentScores, agentWeights) {\n  let confidence = 0;\n  for (let i = 0; i < agentScores.length; i++) {\n    confidence += agentWeights[i] * agentScores[i][disease];\n  }\n  return confidence;\n}\n\nfunction predictDisease(diseaseScores, threshold) {\n  let predictedDiseases = [];\n  for (const disease in diseaseScores) {\n    if (diseaseScores[disease] >= threshold) {\n      predictedDiseases.push(disease);\n    }\n  }\n  return predictedDiseases;\n}\n\n\n// Example usage:\nconst agentScores = [\n  { \"ASF\": 0.8, \"PRRS\": 0.2, \"PED\": 0.1 }, // Agent 1 scores\n  { \"ASF\": 0.7, \"PRRS\": 0.3, \"PED\": 0.2 }  // Agent 2 scores\n];\n\nconst agentWeights = [0.6, 0.4];  // Weights for each agent\nconst threshold = 0.7;\n\nconst diseaseScores = {\n  \"ASF\": calculateConfidence(\"ASF\", agentScores, agentWeights),\n  \"PRRS\": calculateConfidence(\"PRRS\", agentScores, agentWeights),\n  \"PED\": calculateConfidence(\"PED\", agentScores, agentWeights),\n};\n\n\nconst predicted = predictDisease(diseaseScores, threshold);\nconsole.log(\"Predicted Diseases:\", predicted);\n\n\n// Handling Out-of-Distribution (OOD) cases:\nif (predicted.length === 0) {\n  console.log(\"Out-of-Distribution (OOD) case detected. Escalating...\");\n  // Implement escalation protocol:\n  // 1. Alert veterinary expert\n  // 2. Recommend additional diagnostic tests\n} else {\n    //Categorize predictions based on confidence tiers (Section 3.2.3):\n    for(const disease of predicted){\n        const confidence = diseaseScores[disease];\n        if(confidence >= 0.75){\n            console.log(`${disease}: Very High Confidence`);\n        } else if (confidence >= 0.624) {\n            console.log(`${disease}: High Confidence`);\n        } else if (confidence >= 0.375){\n            console.log(`${disease}: Medium Confidence`);\n        } else {\n            console.log(`${disease}: Low Confidence`);\n        }\n    }\n}\n\n```\n\n* **Explanation:** This JavaScript code implements the confidence-weighted decision fusion mechanism. The `calculateConfidence` function computes the weighted average of individual agent scores for each disease.  `predictDisease` function then determines the predicted diseases based on a confidence threshold. It also includes handling for Out-of-Distribution (OOD) cases and confidence tier categorization, mimicking the paper's logic.\n\n\n**2.  State Transitions (Section 3.2.2):**\n\n```javascript\nconst states = {\n  GENERAL: \"G\",\n  EXTERNAL: \"E\",\n  SPECIFIC: \"S\"\n};\n\nfunction transitionState(currentState, userInput) {\n  switch (currentState) {\n    case states.GENERAL:\n      // Logic to determine next state based on userInput (e.g., keyword detection)\n      if (userInput.includes(\"cough\") || userInput.includes(\"diarrhea\")) {\n        return states.SPECIFIC; // Directly to Specific if highly detailed info\n      } else {\n        return states.EXTERNAL; // Usual progression\n      }\n    case states.EXTERNAL:\n      return states.SPECIFIC;\n    case states.SPECIFIC:\n      //  Example logic for reversion if key information is missing:\n      if (userInput.includes(\"uncertain\") || userInput.includes(\"don't know\")) {\n         return states.GENERAL; // Request more general information\n      }\n    default:\n      return currentState;\n  }\n}\n\n// Example usage:\nlet currentState = states.GENERAL;\nconst userInput = \"The pig is lethargic and has a fever.\";\ncurrentState = transitionState(currentState, userInput);\nconsole.log(\"New State:\", currentState); // Output: New State: E\n\nconst userInput2 = \"The pig is coughing and has difficulty breathing.\";\ncurrentState = transitionState(currentState, userInput);\nconsole.log(\"New State:\", currentState); // Output: New State: S\n\n\n```\n\n* **Explanation:**  This implements the state transition logic described in the paper.  The `transitionState` function takes the current state and user input as arguments and returns the next state according to the rules defined in the paper (sequential progression, direct transition, reversion). The example demonstrates how keywords in user input can be used to determine transitions. You'd need to add more sophisticated natural language processing to make this robust.\n\n\n\nThese are just two example implementations. The paper provides a high-level architectural overview and algorithmic concepts, but detailed implementation requires further development, especially regarding natural language understanding, knowledge base integration (RAG), and the LLM interaction.  These implementations provide a starting point for translating the core ideas into functional JavaScript code. They can be expanded upon and integrated with other components, like LLM APIs, to create a more complete prototype.  Further considerations like data preprocessing, error handling, and UI design are also necessary for a real-world application.",
  "simpleQuestion": "Can AI agents diagnose swine diseases faster?",
  "timestamp": "2025-03-20T06:01:26.797Z"
}