{
  "arxivId": "2502.12058",
  "title": "A survey about perceptions of mobility, to inform an agent-based simulator of modal choice",
  "abstract": "In order to adapt to the issues of climate change and public health, urban policies are trying to encourage soft mobility, but the share of the car remains significant. Beyond known constraints, we study here the impact of perception biases on individual choices. We designed a multi-criteria decision model, integrating the influence of habits and biases. We then conducted an online survey, which received 650 responses. We used these to calculate realistic mobility perception values, in order to initialise the environment and the population of a modal choice simulator, implemented in Netlogo. This allows us to visualize the adaptation of the modal distribution in reaction to the evolution of urban planning, depending on whether or not we activate biases and habits in individual reasoning.",
  "summary": "This paper explores how people choose their transportation (car, bike, bus, walking) and builds a simulation to model these choices.  It considers practical factors like cost and time, but also psychological factors like habits and biases.\n\nFor LLM-based multi-agent systems, this research offers insights into:\n\n* **Agent Modeling:**  The described agent model, with priorities, biases, and habits, could inform the design of more realistic and human-like agents in multi-agent simulations. LLMs could be employed to generate diverse agent profiles based on the described criteria.\n* **Simulation Design:** The NetLogo simulation demonstrates a method for simulating complex social systems with relatively simple agent rules. This could be adapted to LLM-based systems, where the LLMs could handle more nuanced decision-making processes within the agents.\n* **Bias Integration:**  The paper’s emphasis on biases and habits underscores the importance of incorporating these factors into agent behavior. LLMs themselves can exhibit biases, and this research provides a framework for explicitly modeling and mitigating such biases within multi-agent systems.\n* **Habit Formation and Change:**  The simulation’s handling of habit formation and disruption provides a valuable model for how LLMs might learn and adapt their behavior within a multi-agent context.  This could also be used to explore how to influence agent behavior and drive system-level change.",
  "takeaways": "This paper explores how cognitive biases and habits influence modal choice (transportation method selection) and presents a multi-agent simulation model. Here's how a JavaScript developer working with LLM-based multi-agent web apps can apply these insights:\n\n**1. Simulating User Behavior with LLMs:**\n\n* **Bias-Aware Agent Design:** The paper highlights biases like *status quo bias* (preference for the current state), *ambiguity bias* (preference for known risks), and *halo effect* (overemphasis of positive attributes). JavaScript developers can use these insights to engineer more realistic agent behavior in simulations or games.  For example, an LLM can be prompted to generate responses reflecting a user's status quo bias regarding their preferred online shopping platform, even when presented with alternatives.\n\n```javascript\n// Example: Using an LLM to simulate status quo bias\nasync function getAgentResponse(agent, options) {\n  const prompt = `Agent ${agent.id} usually uses ${agent.preferredOption}.  Given these options: ${JSON.stringify(options)}, choose one considering their status quo bias.`;\n  const llmResponse = await callLLM(prompt);  // Replace with your LLM API call\n  return parseLLMResponse(llmResponse); // Extract the chosen option\n}\n```\n\n* **Habit Formation and Change:** The simulator models habit formation and disruption.  In web development, this could be applied to personalized recommendations, where an LLM-powered agent learns user preferences over time, factoring in habit-based choices and adapting to disruptions like seasonal changes or new product introductions.\n* **Multi-Criteria Decision Making:** The agents in the paper use a multi-criteria decision model.  JavaScript developers can implement similar logic in their applications using libraries like `multi-criteria-decision-making`.  This is valuable in scenarios like product comparison engines where an LLM could score products based on user-defined criteria (price, features, reviews) and habits.\n\n**2.  Web Application Scenarios:**\n\n* **E-commerce:** LLM-powered agents can assist users in finding products by considering their preferences, habits, and potential biases. An agent could explain why a user might be hesitant to try a new brand despite positive reviews (ambiguity bias).  Libraries like `react` and `vue.js` can be used for building the user interface.\n* **Personalized Learning Platforms:** Agents could personalize learning paths by analyzing user learning styles, habits (e.g., preferred learning times), and addressing potential biases like overconfidence in certain subjects.\n* **Smart Assistants:** An LLM-powered assistant could anticipate user needs by modeling their daily routines and habits. It could also identify potential cognitive biases influencing user decisions (e.g., anchoring bias when making financial decisions) and offer alternative perspectives.\n* **Gaming:** In multi-agent game development, biases and habits can create more realistic and challenging opponents.  Frameworks like `Phaser` and `Babylon.js` could be used to implement the game logic.\n\n**3. Experimenting with JavaScript and Web Technologies:**\n\n* **Browser-Based Simulations:** Implement simplified versions of the NetLogo simulator using JavaScript libraries like `p5.js` or `d3.js` to visualize agent behavior in the browser.\n* **Node.js Backend with LLM Integration:** Use Node.js and libraries like `langchain` to create a backend server for running multi-agent simulations driven by LLMs.  The front-end could be built with any JavaScript framework.\n* **Serverless Functions for Scalability:** Utilize serverless functions (e.g., AWS Lambda, Google Cloud Functions) to run agent simulations on demand, enabling large-scale experiments.\n\n**Key Takeaways for JavaScript Developers:**\n\n* LLMs can be used to simulate realistic user behavior by incorporating cognitive biases and habit formation.\n* Multi-agent systems combined with LLMs can enhance web applications in various domains, from e-commerce to personalized learning.\n* JavaScript frameworks and libraries offer tools for implementing and visualizing multi-agent systems in the browser or on the server.\n\n\nBy understanding the concepts in this paper and applying them creatively, JavaScript developers can leverage the power of multi-agent AI and LLMs to create more engaging, personalized, and intelligent web applications.",
  "pseudocode": "The paper describes a multi-criteria decision-making algorithm and a habit-based decision-making process. Here are the JavaScript implementations and explanations:\n\n```javascript\nfunction calculateScore(agent, mode, values) {\n  let score = 0;\n  for (const criterion in agent.priorities) {\n    score += values[mode][criterion] * agent.priorities[criterion];\n  }\n  return score;\n}\n\nfunction chooseMode(agent, environment, useHabits, useBiases) {\n  let values = environment; // Start with objective values\n\n  if (useBiases) {  // Apply perception filter if biases are enabled\n    values = {}; //  Initialize subjective values object.\n    for (const mode in environment) {\n        values[mode] = {...environment[mode]}; // Shallow copy avoids issues\n        for (const criterion in environment[mode]) {\n            values[mode][criterion] *= agent.filter[mode][criterion];\n        } \n    } \n  }\n\n  let availableModes = Object.keys(values).filter(mode => {\n    if (mode === 'walk' || mode === 'bike') return true; // Walk and Bike always accessible (limited by distance check later)\n\n    if (mode === 'car' && !agent.accessCar) return false; \n\n    if (mode === 'bus' && !agent.accessBus) return false; \n    \n    return true; \n});\n\n\n  if (useHabits && agent.habits[agent.usualMode] > Math.random() * 100) { \n    if (availableModes.includes(agent.usualMode) )\n        return agent.usualMode; // Choose usual mode based on habit\n    else {\n         // Habit failed, usual mode not available\n         availableModes = availableModes.filter(mode => mode != agent.usualMode);\n    }\n  }\n\n  // Distance constraint check\n  availableModes = availableModes.filter(mode => {\n    if (agent.distance > 15 && mode === 'bike') return false;\n    if (agent.distance > 7 && mode === 'walk') return false;\n    return true;\n  });\n\n if (availableModes.length == 0 )\n {\n    console.log(\"No modes available\")\n    return null;\n }\n\n  let bestMode = availableModes[0];\n  let bestScore = calculateScore(agent, bestMode, values);\n\n\n  for (let i = 1; i < availableModes.length; i++) {\n    const mode = availableModes[i];\n    const score = calculateScore(agent, mode, values);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMode = mode;\n    }\n  }\n\n\n  return bestMode;\n}\n\n\n\n// Example Usage (Illustrative):\n\nconst environment = {  // Sample values for each transport mode.\n    car:{ ecology: 20, comfort:90, price: 80, practicality: 90, time: 70, safety:70 },\n    bike:{ ecology: 90, comfort:60, price: 20, practicality: 60, time: 60, safety:40 },\n    bus:{ ecology: 70, comfort:70, price: 50, practicality: 70, time: 50, safety:60 },\n    walk:{ ecology: 95, comfort:50, price: 10, practicality: 50, time: 30, safety:80 },\n}\n\nconst agent = { \n    priorities:{ ecology: 70, comfort:50, price: 60, practicality: 80, time: 70, safety:60 },\n    filter: { // Sample filter, initially set to values between 0.5 and 1.95. Can be adapted over time based on habits\n        car:{ ecology: 1, comfort:1, price: 1, practicality: 1, time: 1, safety:1 },\n        bike:{ ecology: 1, comfort:1, price: 1, practicality: 1, time: 1, safety:1 },\n        bus:{ ecology: 1, comfort:1, price: 1, practicality: 1, time: 1, safety:1 },\n        walk:{ ecology: 1, comfort:1, price: 1, practicality: 1, time: 1, safety:1 },\n    },\n    usualMode: 'car',\n    habits: { car: 50, bike: 0, bus: 0, walk:0 },  // Habits percentages\n    accessCar: true,\n    accessBus: true,\n    distance: 5,\n };\n\nconst chosenMode = chooseMode(agent, environment, true, true);\nconsole.log(\"Chosen mode:\", chosenMode);\n\n\n// Updating agent habits based on chosen mode:\nif (chosenMode) {\n    agent.habits[chosenMode]++;\n\n    // Ensure sum to 100%\n    let sum = 0;\n    for (const mode in agent.habits){\n        sum+= agent.habits[mode];\n    }\n\n    if(sum > 100) {  \n        for (const mode in agent.habits)\n            agent.habits[mode] = Math.round(agent.habits[mode] / sum * 100);\n    }\n}\n\nconsole.log(\"Agent habits:\", agent.habits);\n\n\n\n\n// Example of how to update the agent filter over time based on current habits:\nfor (const mode in agent.habits) {\n    for (const criterion in agent.filter[mode]) {\n        // The filter values gradually adapt towards values that overestimate the habitual mode and underestimates the others\n        if (mode == agent.usualMode)\n        agent.filter[mode][criterion] +=  0.05 * (1.95 - agent.filter[mode][criterion]); //Increase towards 1.95 for habitual mode\n        else\n        agent.filter[mode][criterion] += 0.05 * (0.5 - agent.filter[mode][criterion]); //Decrease towards 0.5 for other modes\n    }\n}\nconsole.log(\"Agent filter:\", agent.filter);\n```\n\n\n**Explanation:**\n\n1. **`calculateScore(agent, mode, values)`:** This function calculates the score for a given `mode` of transportation for a given `agent`, based on the `values` (either objective or subjective after applying the filter). It multiplies each criterion's value by the agent's priority for that criterion and sums them up, implementing the multi-criteria decision-making algorithm.\n\n2. **`chooseMode(agent, environment, useHabits, useBiases)`:**  This function implements the core logic for an agent to choose a transportation mode. \n    * It takes the `agent`, the `environment` (with transportation mode values), and boolean flags `useHabits` and `useBiases` to determine whether to incorporate those factors.\n    * It applies the agent's `filter` to the environment values if `useBiases` is true.\n    * It checks for habit-based decisions if `useHabits` is true.  If the agent's habit for their usual mode is triggered (based on a random draw and habit strength), they stick with that mode.\n    * Finally, it calculates scores for all allowed modes. It handles constraints like car/bus access and distance for walking/cycling.\n    * It selects and returns the mode with the highest score.\n    * The example shows how to update the agent's habits based on the chosen mode.\n\n    * It also provides an example how the agent's filter can be updated over time as habits form.\n\n\n\nThe provided JavaScript code converts the described algorithms into executable functions, making it readily usable for JavaScript developers interested in building multi-agent simulations for mobility choices. The illustrative example usage demonstrates how to initialize agents, define the environment, and run the decision-making process. This provides a solid foundation for further exploration of the concepts outlined in the research paper.",
  "simpleQuestion": "How do perception biases affect modal choice simulation?",
  "timestamp": "2025-02-18T06:05:13.853Z"
}