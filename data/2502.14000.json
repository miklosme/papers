{
  "arxivId": "2502.14000",
  "title": "Human-Artificial Interaction in the Age of Agentic AI: A System-Theoretical Approach",
  "abstract": "Abstract. This paper presents a novel perspective on human-computer interaction (HCI), framing it as a dynamic interplay between human and computational agents within a networked system. Going beyond traditional interface-based approaches, we emphasize the importance of coordination and communication among heterogeneous agents with different capabilities, roles, and goals. A key distinction is made between multi-agent systems (MAS) and Centaurian systems, which represent two different paradigms of human-AI collaboration. MAS maintain agent autonomy, with structured protocols enabling cooperation, while Centaurian systems deeply integrate human and AI capabilities, creating unified decision-making entities. To formalize these interactions, we introduce a framework for communication spaces, structured into surface, observation, and computation layers, ensuring seamless integration between MAS and Centaurian architectures, where colored Petri nets effectively represent structured Centaurian systems and high-level reconfigurable networks address the dynamic nature of MAS. Our research has practical applications in autonomous robotics, human-in-the-loop decision making, and AI-driven cognitive architectures, and provides a foundation for next-generation hybrid intelligence systems that balance structured coordination with emergent behavior.",
  "summary": "This paper proposes a new way to think about human-computer interaction (HCI) by viewing it as a dynamic system of multiple interacting agents, including humans and AI.  It distinguishes between two types of interaction: **multi-agent systems (MAS)**, where agents maintain autonomy and interact through protocols, and **Centaurian systems**, where human and AI capabilities are deeply integrated.  The paper introduces \"communication spaces\" as a framework to model both MAS and Centaurian systems, structured into surface, observation, and computation layers.  Colored Petri nets are used to formalize these interactions.\n\nKey points for LLM-based multi-agent systems include:\n\n* **LLMs enable humans to act as full-fledged agents**, expanding the possibilities for multi-agent interaction.\n* **LLMs enable deeper human-AI integration** in Centaurian systems, facilitating more complex tasks.\n* **Communication spaces** offer a flexible framework for modeling heterogeneous agent interaction, crucial for systems involving LLMs alongside other agent types.\n* **The \"data flywheel\" effect** (continuous learning and adaptation) applies to both agent improvement in MAS and the refinement of human-AI integration in Centaurian systems, making LLMs a powerful tool for evolving multi-agent systems.  This aligns with how communication spaces facilitate flexible interaction.\n* **Formal modeling with Colored Petri nets** provides a rigorous way to design and analyze the complex interactions of LLM-based multi-agent systems, including specifying how LLMs coordinate with other agents.",
  "takeaways": "This research paper provides a valuable theoretical framework for JavaScript developers venturing into LLM-based multi-agent applications. Let's translate the core concepts into practical examples:\n\n**1. Communication Spaces:**\n\n* **Surface Space (JavaScript Implementation):** This is where your web UI interacts with agents.  Use frameworks like React, Vue, or Svelte to create components representing agents.  Each component can have methods for sending and receiving messages. WebSockets provide real-time bidirectional communication.  For natural language processing at the surface, integrate an LLM library like LangChain directly into the component, managing user prompts and agent responses.\n\n```javascript\n// React example (simplified)\nimport { useState, useEffect } from 'react';\nimport { LangChain } from 'langchain';\n\nfunction AgentComponent() {\n  const [message, setMessage] = useState('');\n  const [response, setResponse] = useState('');\n\n  useEffect(() => {\n    const llm = new LangChain(...); // Initialize LLM \n\n    // Example of handling incoming message from another agent via WebSockets \n    socket.on('message', (data) => {\n      llm.process(data).then(result => setResponse(result)); // Process with LLM\n    });\n  }, []);\n\n  const sendMessage = () => {\n    socket.emit('message', message); // Send message via WebSockets\n  };\n\n  return (\n    <div>\n      <input value={message} onChange={(e) => setMessage(e.target.value)} />\n      <button onClick={sendMessage}>Send</button>\n      <p>{response}</p>\n    </div>\n  );\n}\n```\n\n* **Observation Space (JavaScript Implementation):** This involves message routing and transformation.  Use a message broker like Redis or RabbitMQ.  Implement message queues in Node.js to handle the flow.  Define message schemas using something like Protobuf to ensure consistency.  You can create JavaScript functions to parse and transform LLM outputs into structured data for other agents.  LangChain itself facilitates parsing and combining LLM outputs with other tools.\n\n* **Computation Space (JavaScript Implementation):** Here's where your LLM-powered agents reside.  Use Node.js to host your agents. Libraries like LangChain make interacting with LLMs and creating chains for complex reasoning straightforward. You can use a database like MongoDB to persist agent state.\n\n\n**2. Multi-Agent vs. Centaurian:**\n\n* **Multi-agent Scenario (Web Development):** Imagine a collaborative document editing app. Each user is an agent (represented by a JavaScript component), and they interact through a shared document (surface space). The observation space handles conflict resolution and message distribution. LLMs could assist with grammar, style, and even content suggestions, but each user retains full control.\n\n* **Centaurian Scenario (Web Development):** Consider a web-based design assistant. The human designer and the LLM are deeply integrated. The human provides high-level input (surface space), and the LLM generates design variations (computation space), constantly refining them based on user feedback (continuous feedback loop in the observation space).  Here, the human and LLM function as a single unit.\n\n**3. Practical Experiment (JavaScript):**\n\nBuild a simple multi-agent chat application using Node.js and Socket.IO.  Create two agents: one human-controlled through a web interface and one LLM-powered.  Experiment with different interaction rules in the observation space (e.g., moderation, summarization).  This allows you to experiment with the concepts in a controlled environment.\n\n\n**JavaScript Frameworks and Libraries:**\n\n* **LangChain:** For working with LLMs, chains, and agents.\n* **React, Vue, or Svelte:** For building interactive UIs representing agents.\n* **Node.js:** For hosting agent logic and managing message queues.\n* **Socket.IO or WebSockets:** For real-time communication.\n* **Redis or RabbitMQ:** For message brokering in the observation space.\n* **Protobuf:** For defining message schemas.\n* **MongoDB:** For persisting agent state.\n\nBy understanding these concepts and utilizing relevant JavaScript technologies, developers can effectively apply the theoretical framework of the paper to create practical and sophisticated LLM-based multi-agent web applications.  The key is to think about your application's communication flows and how to leverage LLMs to enhance user experience within either a collaborative multi-agent or a deeply integrated Centaurian paradigm.",
  "pseudocode": "```javascript\nfunction register(self, agent) {\n  if (agent.isConcernedWith(self.topic)) {\n    if (agent.ST === \"ON\") {\n      self.CMP.active.push(agent);\n    } else {\n      self.CMP.nonActive.push(agent);\n    }\n  }\n}\n\nfunction deliver(m) {\n  if (self.ST === \"ON\" && self.isConcernedWith(m.topic)) {\n    for (const agent of self.CMP.active) {\n      agent.addToBuffer(m);\n    }\n  }\n}\n\nfunction deregister(self, agent) {\n  const index = self.CMP.active.indexOf(agent);\n  if (index > -1) {\n    self.CMP.active.splice(index, 1);\n  }\n}\n\n\nfunction switchCMP(self, agent) {\n  if (agent.ST === \"OFF\" && self.CMP.active.includes(agent)) {\n    const index = self.CMP.active.indexOf(agent);\n    if(index > -1){\n        self.CMP.active.splice(index, 1);\n        self.CMP.nonActive.push(agent);\n    }\n  }\n  if (agent.ST === \"ON\" && self.CMP.nonActive.includes(agent)) {\n    const index = self.CMP.nonActive.indexOf(agent);\n    if(index > -1){\n        self.CMP.nonActive.splice(index, 1);\n        self.CMP.active.push(agent);\n    }\n  }\n}\n\n```\n\n**Explanation of the algorithms and their purpose:**\n\nThese JavaScript functions model the behavior of a \"group agent\" within a multi-agent or Centaurian system.  The group agent manages communication and coordination between individual agents based on their shared interest in a specific topic.\n\n* **`register(self, agent)`:** This function registers an agent with the group agent.  It checks if the agent is interested in the group's topic and whether the agent is active. If both conditions are true, the agent is added to the list of active members; otherwise, it's added to the list of inactive members.\n\n* **`deliver(m)`:** This function handles message delivery within the group. If the group agent is active and the message is relevant to its topic, the message is delivered to all active members of the group by adding it to their individual message buffers. This ensures that all active participants receive updates and maintain a shared understanding of the ongoing activities.\n\n* **`deregister(self, agent)`:** This function removes an agent from the group.  This typically happens when the agent is no longer interested in the topic or due to a decision by the coordination mechanism. The agent is removed from the `active` array of the `CMP` object if present.\n\n* **`switchCMP(self, agent)`:**  This function updates the activity status of an agent within the group. If an agent's status changes from \"ON\" to \"OFF\", it's moved from the active members list to the inactive members list. Conversely, if the status changes from \"OFF\" to \"ON\", it's moved from the inactive list to the active list.  This maintains consistency in the group's membership based on real-time activity changes.\n\n\nThese functions together provide a mechanism for managing dynamic group membership and communication within a multi-agent system, facilitating coordination and information sharing among agents interested in the same topic. This is particularly relevant in scenarios like distributed task management, collaborative problem-solving, and real-time information dissemination, where agents need to dynamically join or leave groups and maintain consistent communication patterns.",
  "simpleQuestion": "How can LLMs coordinate with human agents in apps?",
  "timestamp": "2025-02-21T06:03:58.013Z"
}