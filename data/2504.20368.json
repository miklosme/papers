{
  "arxivId": "2504.20368",
  "title": "AKIBoards: A Structure-Following Multiagent System for Predicting Acute Kidney Injury",
  "abstract": "Abstract. Diagnostic reasoning entails a physician's local (mental) model based on an assumed or known shared perspective (global model) to explain patient observations with evidence assigned towards a clinical assessment. But in several (complex) medical situations, multiple experts work together as a team to optimize health evaluation and decision-making by leveraging different perspectives. Such consensus-driven reasoning reflects individual knowledge contributing toward a broader perspective on the patient. In this light, we introduce STRUCture-following for Multiagent Systems (STRUC-MAS), a framework automating the learning of these global models and their incorporation as prior beliefs for agents in multiagent systems (MAS) to follow. We demonstrate proof of concept with a prosocial MAS application for predicting acute kidney injuries (AKIs). In this case, we found that incorporating a global structure enabled multiple agents to achieve better performance (average precision, AP) in predicting AKI 48 hours before onset (structure-following-fine-tuned, SF-FT, AP=0.195; SF-FT-retrieval-augmented generation, SF-FT-RAG, AP=0.194) vs. baseline (non-structure-following-FT, NSF-FT, AP=0.141; NSF-FT-RAG, AP=0.180) for balanced precision-weighted-recall-weighted voting. Markedly, SF-FT agents with higher recall scores reported lower confidence levels in the initial round on true positive and false negative cases. But after explicit interactions, their confidence in their decisions increased (suggesting reinforced belief). In contrast, the SF-FT agent with the lowest recall decreased its confidence in true positive and false negative cases (suggesting a new belief). This approach suggests that learning and leveraging global structures in MAS is necessary prior to achieving competitive classification and diagnostic reasoning performance.",
  "summary": "This paper introduces STRUC-MAS (STRUCture-following for Multiagent Systems), a framework for building multi-agent systems that learn and follow a shared \"global structure\" of a problem. It demonstrates this framework with AKIBoards, a multi-agent system for predicting Acute Kidney Injury (AKI).\n\nKey points for LLM-based multi-agent systems:\n\n* **Global structure improves performance:**  Learning and incorporating a global structure of the data (relationships between variables) significantly improved the performance of individual LLMs in predicting AKI compared to LLMs without this shared knowledge.\n* **Agent interaction refines beliefs:** Explicit interactions between agents, simulating a \"smart rounds\" scenario, allowed agents to refine their predictions and confidence levels, akin to knowledge distillation.  Weaker agents learned from stronger ones, and stronger agents reinforced their beliefs.\n* **Explainability is key:** The system uses agent-based terms (ABT) and multi-agent records (MAR) to log and analyze agent interactions and reasoning, providing insights into their decision-making processes.\n* **Prosocial focus:** The framework incorporates a \"prosocial layer\" to ensure responsible use, aiming to augment rather than replace human expertise.\n* **RAG augments structure-following:** Retrieval Augmented Generation (RAG) further enhanced performance when combined with structure-following, allowing agents to leverage similar past cases.\n* **Smart rounds for efficiency:** The \"smart rounds\" approach optimizes agent interactions to reach consensus efficiently, employing early stopping when performance gains plateau.",
  "takeaways": "This research paper introduces the concept of STRUC-MAS (Structure-following for Multiagent Systems), a framework for improving LLM-based multi-agent systems by incorporating global structure learning. Here's how a JavaScript developer can apply these insights to web development:\n\n**1. Building a Collaborative Content Creation Platform:**\n\nImagine building a platform where multiple LLMs collaborate to write articles or stories.  Each LLM agent could specialize in a different aspect, such as character development, plot progression, or dialogue.  \n\n* **Global Structure (JavaScript Implementation):** Use a JavaScript object to represent the story's global structure, outlining key plot points, character arcs, and overall theme. This could be generated by an initial LLM or manually defined.  Share this structure with each agent.\n* **Agents (JavaScript Implementation):** Use a library like LangChain or LlamaIndex to interact with each LLM. Each agent receives the global structure and a specific role.  Their prompts include instructions to adhere to the structure while contributing their expertise. For instance, the dialogue agent focuses on writing realistic conversations within the defined plot points.\n* **Smart Rounds (JavaScript Implementation):** Implement a loop in JavaScript where agents iteratively refine the content. Each round, agents could evaluate other agents' contributions (e.g., using similarity metrics like BERTScore implemented in JavaScript), updating their own output based on feedback. This allows for iterative refinement.\n* **Frontend Integration:** Display the evolving story on the frontend using a framework like React or Vue.js. Show each agent's contribution and the overall combined output. Allow user interaction to steer the story's direction, modifying the global structure.\n\n**2. Developing an Intelligent Customer Support System:**\n\nMultiple LLM agents could handle different aspects of customer support, such as technical issues, billing inquiries, or product information.\n\n* **Global Structure (JavaScript Implementation):**  A knowledge graph implemented in JavaScript (e.g., using a graph database like Neo4j and a JavaScript driver) can represent the product or service information, linking different aspects. This becomes the global structure shared with the agents.\n* **Agents (JavaScript Implementation):** Each LLM agent specializes in a domain, querying the knowledge graph (global structure) and using RAG to provide informed answers. For example, the billing agent queries the billing section of the knowledge graph and accesses previous billing issue resolutions for relevant information.\n* **Smart Rounds (JavaScript Implementation):** If a customer issue requires multiple domains, implement smart rounds. Agents can communicate, requesting information from each other via message passing.  For example, a technical issue related to a specific product version can trigger the technical agent to request version information from the product information agent.\n* **Frontend Integration:** Integrate the multi-agent system with a chat interface built with a JavaScript framework. Display agents' contributions and the overall resolution to the customer.\n\n**3. Creating a Personalized Learning Platform:**\n\nDifferent LLM agents can personalize learning paths, provide feedback, and generate quizzes based on a student's learning style and progress.\n\n* **Global Structure (JavaScript Implementation):**  A curriculum, represented as a JavaScript object, containing learning objectives, topics, and dependencies, serves as the global structure.\n* **Agents (JavaScript Implementation):** Each LLM agent takes on a different role, such as content delivery, assessment, or personalized feedback. The content delivery agent uses the curriculum to guide the student through topics.  The assessment agent generates quizzes based on the learning objectives.  The feedback agent analyzes student performance and adapts the learning path.\n* **Smart Rounds (JavaScript Implementation):** Implement a loop where agents evaluate student progress and adapt the learning path. For example, based on quiz results, the feedback agent can inform the content delivery agent to revisit specific topics.\n* **Frontend Integration:** Use a JavaScript framework to build the learning platform interface, dynamically displaying content, quizzes, and personalized feedback.\n\n\n**Key JavaScript Technologies and Libraries:**\n\n* **LLM Interaction:** LangChain, LlamaIndex\n* **Frontend Frameworks:** React, Vue.js, Angular\n* **Graph Databases:** Neo4j, with JavaScript drivers\n* **Similarity Metrics:** BERTScore Implementations in JavaScript\n* **Message Passing (for Smart Rounds):**  Consider using libraries enabling inter-process communication if agents run in separate processes.  For simple interactions within a single process, standard JavaScript function calls and event emitters can be utilized.\n\n\nBy combining these technologies and applying the principles of STRUC-MAS, JavaScript developers can create sophisticated LLM-based multi-agent applications that are more effective, adaptable, and capable of complex interactions. Remember to consider ethical implications, ensure responsible AI usage, and continuously evaluate the system's performance and fairness.",
  "pseudocode": "The paper includes one equation that can be considered analogous to a pseudocode block. It defines the \"prosocial score\" (PScore) used to determine whether the multi-agent system should run based on the issues it addresses.\n\n**Equation 1 (PScore Calculation):**\n\n```\nPScore = i₁α₁ + ··· + inan\n```\n\n**JavaScript Equivalent and Explanation:**\n\n```javascript\nfunction calculatePScore(issues) {\n  let pScore = 0;\n  for (const issue of issues) {\n    pScore += issue.value * issue.weight;\n  }\n  return pScore;\n}\n\n// Example usage:\nconst issues = [\n  { name: \"Health professional shortages\", value: true, weight: 0.333 },\n  { name: \"Unavailable reasoning\", value: true, weight: 0.333 },\n  { name: \"General support\", value: true, weight: 0.333 },\n];\n\n\nconst pScore = calculatePScore(issues);\n\nif (pScore >= 0.336) {\n  console.log(\"PScore:\", pScore, \"- System permitted to run.\");\n  // Proceed with running the multi-agent system\n} else {\n  console.log(\"PScore:\", pScore, \"- System NOT permitted to run.\");\n  // Do not run the system\n}\n```\n\n**Explanation:**\n\nThe `calculatePScore` function takes an array of `issues` as input. Each `issue` is an object with properties:\n\n* `name`:  A descriptive name of the issue.\n* `value`: A boolean representing whether the system addresses this issue (true) or not (false). In the paper, true maps to 0.99 and false to 0.01.  For simplicity and clarity, this conversion has been handled directly within the `issues` array declaration in the example usage section, where boolean `true`/`false` values are assigned.\n* `weight`:  The relative importance of the issue (a number between 0 and 1). All weights must sum to 1.\n\nThe function iterates through the issues, multiplying each issue's `value` by its `weight` and adding the result to the `pScore`. Finally, it returns the calculated `pScore`. The system is allowed to run only if the `pScore` is greater than or equal to the minimum threshold (0.336 in the paper).  This threshold is derived from the minimum value any one issue could contribute (which is 0.01 according to the paper), assuming there are three issues with equal weight.\n\nThis JavaScript code provides a more concrete and executable representation of the PScore calculation described in the paper, making it easier for JavaScript developers to understand and implement the concept in their own multi-agent applications.",
  "simpleQuestion": "Can shared knowledge improve LLM agent accuracy?",
  "timestamp": "2025-04-30T05:02:45.781Z"
}