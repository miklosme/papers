{
  "arxivId": "2409.15005",
  "title": "Method of Equal Shares with Bounded Overspending",
  "abstract": "In participatory budgeting (PB), voters decide through voting which subset of projects to fund within a given budget. Proportionality in the context of PB is crucial to ensure equal treatment of all groups of voters. However, pure proportional rules can sometimes lead to suboptimal outcomes. We introduce the Method of Equal Shares with Bounded Overspending (BOS Equal Shares), a robust variant of Equal Shares that balances proportionality and efficiency. BOS Equal Shares addresses inefficiencies inherent in strict proportionality guarantees yet still provides good proportionality similar to the original Method of Equal Shares. In the course of the analysis, we also discuss a fractional variant of the method which allows for partial funding of projects.",
  "summary": "This paper investigates fairness and efficiency in participatory budgeting, where voters decide how to allocate a budget among proposed projects. The authors propose a new algorithm, *Bounded Overspending (BOS)*,  as a fairer and more efficient alternative to the existing *Method of Equal Shares*. BOS improves proportionality, ensuring diverse voter groups can fund projects, particularly in scenarios with limited budgets.\n\nWhile not directly addressing LLMs, BOS offers valuable insights for LLM-based multi-agent systems:\n\n* **Resource allocation:**  BOS provides a mechanism for fairly allocating limited resources (like processing power or bandwidth) among multiple agents with potentially conflicting goals, especially relevant in resource-constrained environments. \n* **Fair decision-making:**  The paper emphasizes the importance of proportionality and fairness in decision-making processes, crucial when multiple LLM agents, potentially representing different stakeholders, need to reach consensus.\n* **Mechanism design for LLMs:**  BOS highlights the challenges and considerations in designing robust and fair mechanisms for LLM-based multi-agent systems, particularly when dealing with complex preferences and potential manipulation.",
  "takeaways": "This paper explores enhancing proportionality in participatory budgeting (PB) scenarios, which might seem to have little to do with LLM-powered multi-agent AI web apps at first glance. However, if you dig deeper, there are valuable takeaways for JavaScript developers working on such systems:\n\n**1. Resource Allocation in LLM-Based Agents:**\n\n* **Imagine building a collaborative writing app powered by multiple LLMs.** Each LLM agent, with its own style and expertise, contributes to the final text. You can think of the \"budget\" in this case as the total processing power or time allocated for the task.\n* **The paper's exploration of \"Bounded Overspending\" (BOS) offers a unique approach.**  Instead of strictly adhering to pre-allocated resources for each agent (like the classic \"Method of Equal Shares\"), BOS allows agents to dynamically request more resources if their contribution is deemed valuable. \n* **In JavaScript, you could implement a resource manager that monitors each LLM agent's output quality and adjusts its processing time accordingly.** Libraries like `workerpool` or `pm2` can help manage asynchronous tasks and distribute workload.\n\n```javascript\n// Conceptual example using workerpool\nconst workerpool = require('workerpool');\n\nconst pool = workerpool.pool('./llmAgent.js');\n\nasync function processTask(task) {\n  const agent = await pool.proxy(); \n  const result = await agent.processText(task.text, task.budget); // Pass initial budget\n\n  // Logic to evaluate result quality and potentially request more budget\n  if (result.quality > threshold) { \n    // ... request additional budget from resource manager\n  }\n\n  return result;\n} \n```\n\n**2.  Fairness and Representation in Agent Interactions:**\n\n* **Consider a multi-agent news aggregator where each agent focuses on a specific topic.** The challenge is ensuring diverse perspectives are represented in the final newsfeed, even if some topics are inherently more \"popular\" (like in the paper's \"Selecting Unpopular Projects\" example).\n* **BOS+ offers a strategy for balancing representation.** It prioritizes agents representing \"under-represented\" topics by temporarily boosting their influence when their topics are relevant, preventing dominant agents from monopolizing the newsfeed.\n* **You could translate this into your JavaScript app by implementing a weighting system.**  Frameworks like TensorFlow.js can be used to create a simple neural network that learns to adjust agent weights based on topic frequency and user feedback.\n\n**3. Dynamic Task Prioritization:**\n\n* **The concept of dynamically adjusting resource allocation based on the value of an agent's potential contribution has broader applications.**  In a web app with multiple LLM-powered features (e.g., chatbots, content summarizers, code generators), you could use a similar mechanism to prioritize tasks.\n* **If a user's request triggers a high-priority task (e.g., a critical error in the code generator), the system could temporarily allocate more resources to that agent, delaying less critical tasks (like a chatbot response).**  This dynamic allocation ensures crucial tasks are handled efficiently.\n\n**Key Libraries and Frameworks:**\n\n* **TensorFlow.js:** For building and training simple neural networks to handle agent weighting.\n* **workerpool, pm2:**  For managing asynchronous LLM agent tasks and resource allocation.\n* **Socket.IO:**  For real-time communication and data synchronization between agents.\n* **Node.js:**  For building the backend infrastructure to handle agent communication and resource management.\n\n**Remember:** This paper provides a theoretical foundation. Your JavaScript implementation will require careful adaptation and experimentation to fit the specific constraints and requirements of your multi-agent web application.",
  "pseudocode": "```javascript\nfunction fractionalEqualShares(candidates, voters, budget) {\n  // Initialize the selected fractions of projects to 0.\n  const W = {}; \n  for (const candidate of candidates) {\n    W[candidate.id] = 0; \n  }\n\n  // Initially, each voter gets an equal share of the budget.\n  const b = {}; \n  for (const voter of voters) {\n    b[voter.id] = budget / voters.length; \n  }\n\n  // Set of voters with a non-zero budget.\n  let S = new Set(voters.map(voter => voter.id));\n\n  // Continue as long as there are candidates to buy and voters with budget.\n  while (S.size > 0 && candidates.some(candidate => W[candidate.id] !== 1)) {\n    // Find the candidate with the lowest cost per total utility ratio.\n    let [c, minRatio] = [null, Infinity];\n    for (const candidate of candidates) {\n      if (W[candidate.id] !== 1 && voters.reduce((sum, voter) => sum + voter.utilities[candidate.id], 0) > 0) {\n        const ratio = candidate.cost / voters.reduce((sum, voter) => sum + voter.utilities[candidate.id], 0);\n        if (ratio < minRatio) {\n          [c, minRatio] = [candidate, ratio];\n        }\n      }\n    }\n\n    // Calculate the purchase ratio and maximum affordable fraction.\n    const p = minRatio;\n    const a = Math.min(\n      1 - W[c.id],\n      Math.min(...[...S].map(voterId => b[voterId] / (p * voters.find(voter => voter.id === voterId).utilities[c.id])))\n    );\n\n    // Update the selected fraction of the project.\n    W[c.id] += a;\n\n    // Update the budgets of the supporting voters.\n    for (const voter of voters) {\n      if (S.has(voter.id) && voter.utilities[c.id] > 0) {\n        b[voter.id] -= a * p * voter.utilities[c.id];\n        if (b[voter.id] === 0) {\n          S.delete(voter.id);\n        }\n      }\n    }\n\n    // Update the remaining budget.\n    budget -= a * c.cost;\n  }\n\n  // Buy remaining affordable projects if any.\n  if (budget > 0) {\n    for (const candidate of candidates) {\n      if (W[candidate.id] !== 1 && budget >= (1 - W[candidate.id]) * candidate.cost) {\n        W[candidate.id] = 1;\n        budget -= (1 - W[candidate.id]) * candidate.cost;\n      }\n    }\n  }\n\n  return W;\n}\n```\n\n**Explanation:**\n\nThe `fractionalEqualShares` function implements the **Fractional Equal Shares (FrES)** algorithm for participatory budgeting. This algorithm aims to distribute a given budget among a set of candidate projects based on voter preferences, allowing for partial funding of projects.\n\n**Purpose:**\n\n* **Fair Allocation:** FrES seeks to fairly allocate the budget, ensuring that groups of voters with similar preferences receive a proportional share of funding.\n* **Fractional Funding:** Unlike traditional participatory budgeting algorithms that only allow for fully funding or rejecting a project, FrES permits the allocation of funds to fractions of projects, leading to potentially more efficient use of the budget.\n\n**Algorithm Steps:**\n\n1. **Initialization:** \n   * Set the selected fraction of each project (`W`) to 0.\n   * Each voter is given an equal virtual budget (`b`).\n2. **Iterative Project Selection:** \n   * Find the candidate project (`c`) with the lowest cost-to-utility ratio (`p`), considering only projects that are not yet fully funded.\n   * Calculate the maximum affordable fraction (`a`) of the selected project that can be purchased without exceeding any voter's budget.\n   * Update the selected fraction (`W`) of the chosen project.\n   * Deduct the cost of the purchased fraction from the supporting voters' budgets.\n   * Remove voters with depleted budgets from the active set (`S`).\n3. **Budget Exhaustion or Completion:** \n   * The loop continues until either the budget is exhausted or all remaining candidates are either fully funded or have no remaining supporters with budget.\n4. **Final Allocation:** \n   * If there's any remaining budget, it's used to purchase as much of the remaining affordable projects as possible.\n5. **Output:** \n   * The function returns a dictionary (`W`) indicating the fraction of each project that was selected for funding.\n\n**Key Concepts:**\n\n* **Cost-to-Utility Ratio (p):**  This represents the price per unit of utility that voters are willing to pay for a project. Projects with lower ratios are considered more desirable.\n* **Affordable Fraction (a):** This signifies the portion of a project that can be purchased given the current budget and voter preferences.\n\n**Advantages:**\n\n* **Enhanced Fairness:** By allowing fractional funding, FrES can potentially satisfy a broader range of voter preferences compared to algorithms restricted to binary project selection.\n* **Improved Budget Utilization:**  The ability to partially fund projects allows for a potentially more efficient allocation of resources.\n\n**Limitations:**\n\n* **Computational Complexity:**  Determining the optimal fractional allocation can be computationally challenging for larger problem instances.\n* **Practical Implementability:**  The concept of partially funding projects might not be straightforward to translate into real-world scenarios for certain applications.\n\nThe `fractionalEqualShares` function provides a JavaScript implementation of this algorithm, allowing developers to experiment with and adapt it for various participatory budgeting scenarios within their applications.",
  "simpleQuestion": "How to fairly fund projects with limited budget?",
  "timestamp": "2024-09-24T05:01:38.266Z"
}