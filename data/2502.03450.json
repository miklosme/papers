{
  "arxivId": "2502.03450",
  "title": "A Schema-Guided Reason-while-Retrieve framework for Reasoning on Scene Graphs with Large-Language-Models (LLMs)",
  "abstract": "Scene graphs have emerged as a structured and serializable environment representation for grounded spatial reasoning with Large Language Models (LLMs). In this work, we propose SG-RwR, a Schema-Guided Retrieve-while-Reason framework for reasoning and planning with scene graphs. Our approach employs two cooperative, code-writing LLM agents: a (1) Reasoner for task planning and information queries generation, and a (2) Retriever for extracting corresponding graph information following the queries. Two agents collaborate iteratively, enabling sequential reasoning and adaptive attention to graph information. Unlike prior works, both agents are prompted only with the scene graph schema rather than the full graph data, which reduces the hallucination by limiting input tokens, and drives the Reasoner to generate reasoning trace abstractly. Following the trace, the Retriever programmatically query the scene graph data based on the schema understanding, allowing dynamic and global attention on the graph that enhances alignment between reasoning and retrieval. Through experiments in multiple simulation environments, we show that our framework surpasses existing LLM-based approaches in numerical Q&A and planning tasks, and can benefit from task-level few-shot examples, even in the absence of agent-level demonstrations. Project code will be released.",
  "summary": "This paper introduces SG-RwR, a framework for enhancing LLM reasoning on scene graphs, useful for tasks like spatial planning and question answering.  It employs two cooperating LLM agents, a Reasoner and a Retriever, that communicate iteratively.  Crucially, both agents operate based on the scene graph *schema* rather than the full graph data, which improves efficiency and reduces hallucinations. The Retriever uses this schema to generate code for dynamically querying the graph, providing targeted information to the Reasoner.  The Reasoner can also write code to utilize external tools for numerical reasoning and sub-problem solving, further improving accuracy and allowing it to tackle more complex tasks.  Experiments show SG-RwR outperforms baseline methods, particularly in few-shot settings and complex environments. Key to its success is the combination of iterative reasoning, a two-agent design, and the schema-guided code-writing approach.",
  "takeaways": "This paper presents a compelling case for using a \"reason-while-retrieve\" (RwR) strategy with LLMs for complex tasks involving scene graphs, particularly relevant for multi-agent applications in web development.  Let's translate these insights into practical examples for a JavaScript developer:\n\n**Scenario 1: Collaborative Web Design with Multi-Agent System**\n\nImagine building a multi-agent system where one agent (the \"Designer\" agent) is tasked with creating a website layout based on user requirements, and another agent (the \"Resource\" agent) fetches relevant design components from a large database represented as a scene graph.\n\n* **Problem:**  Directly feeding the entire scene graph (containing all available UI elements, styles, and assets) to the Designer agent can overwhelm it with information, leading to hallucinations and inefficient designs.\n\n* **SG-RwR Solution (JavaScript Implementation):**\n\n```javascript\n// Designer Agent (using a hypothetical LLM interface)\nasync function designerAgent(userRequirements, schema) {\n  let design = {elements: []};\n  let currentStep = \"Start\";\n  while (currentStep !== \"Done\") {\n    const query = await llm.generateQuery(design, userRequirements, schema, currentStep);\n    console.log(\"Designer Query:\", query);\n    const retrievedData = await resourceAgent(query, schema);\n    console.log(\"Retrieved Data:\", retrievedData);\n    const {newDesign, nextStep} = await llm.updateDesign(design, retrievedData, schema);\n    design = newDesign;\n    currentStep = nextStep;\n  }\n  return design;\n}\n\n// Resource Agent (using a graph database library like Neo4j or a custom implementation)\nasync function resourceAgent(query, schema) {\n  // Convert LLM query into a database query based on the schema\n  const dbQuery = translateQuery(query, schema);  // This function needs to be implemented\n  const results = await executeDBQuery(dbQuery); // This function interacts with the DB\n  return results;\n}\n\n// Schema Example (simplified)\nconst schema = {\n  nodes: [\"Button\", \"Image\", \"Text\", \"Container\"],\n  edges: [\"contains\", \"next_to\", \"below\"],\n  nodeAttributes: [\"color\", \"size\", \"text\"],\n  edgeAttributes: [\"alignment\"]\n};\n```\n\n* **Explanation:** The Designer agent iteratively queries the Resource agent for specific elements based on the current design state and user requirements.  The `translateQuery` function is crucial; it maps the natural language query from the Designer agent into a structured database query according to the `schema`. This could involve using a template-based approach or a more sophisticated natural language understanding module.  This schema-guided querying avoids overloading the LLM and promotes efficient retrieval.\n\n\n**Scenario 2: Multi-Agent Game Development (e.g., using Phaser)**\n\nConsider developing a game with multiple AI-controlled characters, each acting as an agent. Each agent needs to interact with the game world, represented by a scene graph containing information about objects, terrain, and other agents.\n\n* **Problem:**  Supplying the entire game state to each agent at every step is computationally expensive, especially in a large game world.\n\n* **SG-RwR Solution (JavaScript Implementation - Conceptual):**\n\n```javascript\n// Inside each agent's update loop (using Phaser as an example)\nfunction update(time, delta) {\n  const relevantSchema = getRelevantSchema(this.agentType, currentTask); // Filter schema\n  const query = llm.generateActionQuery(this.state, relevantSchema, currentTask);\n  const retrievedData = gameWorld.querySceneGraph(query, relevantSchema); // Game-specific\n  const action = llm.decideAction(retrievedData, relevantSchema, currentTask);\n  this.executeAction(action); // Phaser action\n}\n```\n\n* **Explanation:** Each agent focuses its attention by querying only the relevant portion of the scene graph using the `getRelevantSchema` function based on its current task and type.  The `gameWorld.querySceneGraph`  function translates the LLM's query to interact with the Phaser scene graph (or a separate graph representation). This minimizes data transfer and processing.\n\n**Key Takeaways for JavaScript Developers:**\n\n* **Schema as an Interface:**  The schema is the key to bridging the gap between the LLM's natural language processing and the structured data in your application.  Invest in designing a comprehensive and flexible schema.\n* **Iterative Queries and Code Generation:**  The RwR approach requires structuring your agents to operate in a loop, querying and acting iteratively.  Leverage JavaScript's `async/await` for efficient asynchronous operations.\n* **Graph Database Integration:** Consider using graph databases like Neo4j for efficient storage and retrieval of scene graph data, especially in complex web applications.\n* **LLM Libraries:** Explore JavaScript libraries like LangChain.js or Transformers.js to integrate LLMs into your multi-agent systems.\n\n\nBy incorporating these insights and examples, JavaScript developers can harness the power of LLMs for creating sophisticated and efficient multi-agent systems in various web development scenarios. Remember to address hallucination and debugging, which are crucial considerations when working with LLMs for code generation, as discussed in the paper.  Experiment and iterate to find the optimal balance between reasoning and retrieval for your specific use case.",
  "pseudocode": "```javascript\n// Retriever Code Example (Figure 2, q2)\nfunction findDoorsBetweenRooms(G, room1_id, room2_id) {\n    const doors = [];\n    for (const node in G.nodes) {\n      if (G.nodes[node].type === 'door') {\n        const neighbors = G.neighbors(node);\n        if (neighbors.includes(room1_id) && neighbors.includes(room2_id)) {\n          doors.push({\n            id: node,\n            color: G.nodes[node].color,\n            is_locked: G.nodes[node].is_locked,\n            coordinate: G.nodes[node].coordinate,\n          });\n        }\n      }\n    }\n    if (doors.length === 0) return null; // Or handle no doors found\n    return doors;\n}\n\n// Retriever Code Example (Figure 5, last query)\nfunction findItemsInRoom(G, roomId) {\n  const items = [];\n  for (const node in G.nodes) {\n    // Assuming rooms have a 'contains' relationship with items\n    if (G.edges(node, roomId).relationships.includes(\"INSIDE\")) {\n      items.push({\n          id: node,\n          type: G.nodes[node].type,\n          color: G.nodes[node].color,\n          coordinate: G.nodes[node].coordinate\n      });\n    }\n  }\n\n  if (items.length === 0) return null; // Or handle no items found\n  return items;\n\n}\n\n\n// Reasoner Code Example (Figure 2, a_t)\nfunction checkTraversability(init_coord, target_coord, items, ...) {\n  // This would call a pathfinding algorithm, likely A*\n  const path = findPath(init_coord, target_coord, items, ...); // Assume 'findPath' exists.\n  if (path) {\n    const obstaclesToRemove = findObstaclesInPath(path, items);\n    return { traversable: true, obstacles: obstaclesToRemove};\n  } else {\n    return { traversable: false, obstacles: [] }; // Or handle no path found\n  }\n}\n\n// NumQ&A Example (Figure 8 (b), RwR)\nfunction findRoomWithNItemsOfType(G, itemType, itemColor, targetCount) {\n    for (const node in G.nodes) {\n        if(G.nodes[node].type === 'room') {\n            let itemCount = 0;\n            for (const neighbor in G.neighbors(node)) {\n                if(G.nodes[neighbor].type === itemType && G.nodes[neighbor].color === itemColor){\n                    itemCount++;\n                }\n            }\n            if (itemCount === targetCount){\n                return node;\n            }\n\n        }\n    }\n    return null; // Or handle room not found\n}\n```\n\n**Explanations:**\n\n* **`findDoorsBetweenRooms(G, room1_id, room2_id)`:** This function iterates through the graph's nodes, looking for nodes of type 'door'. It then checks if a given door connects two specified rooms by examining its neighbors. It returns an array of door objects that connect the specified rooms or null if no connection exists.  This illustrates the Retriever's code generation for structured graph queries based on the schema.\n\n* **`findItemsInRoom(G, roomId)`:** This function retrieves all items within a given room. It showcases how the retriever can generate code to filter graph information based on a free-form query by the reasoner.\n\n* **`checkTraversability(init_coord, target_coord, items, ...)`:** This function determines if a path exists between two coordinates within a room, considering a list of potential obstacles (items).  It calls a hypothetical `findPath` function (which would implement a pathfinding algorithm like A*) and returns an object indicating traversability and any obstacles to be removed. This illustrates how the Reasoner uses code and external tools for more complex sub-problems.\n\n* **`findRoomWithNItemsOfType(G, itemType, itemColor, targetCount)`:** This function searches the graph for a room containing exactly `targetCount` number of items of a specified type and color.  It highlights the benefit of code-writing in the retriever for accurate quantitative reasoning, a weakness of LLMs. This functionality can mitigate hallucinations observed in the baseline models in Figure 8 (b).\n\n\nThese JavaScript code snippets demonstrate how the core concepts of the paper, such as schema-guided retrieval, code-writing agents, and iterative reasoning, can be translated into concrete, workable implementations. They showcase how the framework enables more robust and accurate solutions compared to relying solely on LLMs for graph reasoning.",
  "simpleQuestion": "Can LLMs collaboratively reason using scene graphs?",
  "timestamp": "2025-02-06T06:05:14.612Z"
}