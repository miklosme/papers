{
  "arxivId": "2405.11804",
  "title": "(PERHAPS) BEYOND HUMAN TRANSLATION: HARNESSING MULTI-AGENT COLLABORATION FOR TRANSLATING ULTRA-LONG LITERARY TEXTS \n",
  "abstract": "Recent advancements in machine translation (MT) have significantly enhanced translation quality across various domains. However, the translation of literary texts remains a formidable challenge due to their complex language, figurative expressions, and cultural nuances. In this work, we introduce a novel multi-agent framework based on large language models (LLMs) for literary translation, implemented as a company called TRANSAGENTS, which mirrors traditional translation publication process by leveraging the collective capabilities of multiple agents, to address the intricate demands of translating literary works. To evaluate the effectiveness of our system, we propose two innovative evaluation strategies: Monolingual Human Preference (MHP) and Bilingual LLM Preference (BLP). MHP assesses translations from the perspective of monolingual readers of the target language, while BLP uses advanced LLMs to compare translations directly with the original texts. Empirical findings indicate that despite lower d-BLEU scores, translations from TRANSAGENTS are preferred by both human evaluators and LLMs over human-written references, particularly in genres requiring domain-specific knowledge. We also highlight the strengths and limitations of TRANSAGENTS through case studies and suggests directions for future research. \n",
  "summary": "This paper introduces TRANSAGENTS, a novel multi-agent system for literary translation using Large Language Models (LLMs). It simulates a translation company where different LLM agents with specific roles (editor, translator, localization specialist, etc.) collaborate to translate literary texts. \n\nKey points for LLM-based multi-agent systems:\n\n* **Collaboration Strategies:** The system utilizes two collaborative strategies: Addition-by-Subtraction, where agents iteratively add and refine content, and Trilateral Collaboration, where agents are responsible for action, critique, and judgment.\n* **Role Specialization:** LLMs are assigned distinct roles with specific prompts to enhance realism and simulate real-world translation processes.\n* **Evaluation Challenges:** The paper proposes two novel evaluation strategies (monolingual human preference and bilingual LLM preference) to address the subjective nature of literary translation and limitations of traditional metrics like BLEU.\n* **Content Omission Issues:** Despite showing promise, the system still exhibits significant content omission issues, highlighting an area for future improvement in LLM-based translation. \n",
  "takeaways": "This paper presents fascinating insights into using multi-agent LLM systems for complex tasks like literary translation. Here are practical examples a JavaScript developer could draw from it:\n\n**1. Building a Collaborative Content Creation Tool:**\n\n* **Scenario:** Imagine a web app for writers where multiple AI agents assist in crafting a story.\n* **Applying the Paper:**\n    * **Agent Roles:**  Emulate TRANSAGENTS' structure. Use a JavaScript framework like LangChain to manage agents acting as \"Idea Generator,\" \"Style Editor,\" \"Fact Checker,\" and \"Dialogue Specialist.\"\n    * **Addition-by-Subtraction:** When an agent proposes text, another can refine it. This is achievable with libraries like `diff` for text comparison and a LLM to guide the refinement process.\n    * **Trilateral Collaboration:**  A \"Judge\" agent (perhaps a more fine-tuned LLM) could decide if the combined output is good enough or needs more iterations.\n* **Example:**\n    ```javascript\n    // Simplified example using LangChain\n    const ideaAgent = new Agent({ llm: ideaLLM, role: 'Generate story ideas' });\n    const editorAgent = new Agent({ llm: editorLLM, role: 'Polish writing style' });\n\n    let storyText = await ideaAgent.run('Give me a sci-fi plot');\n    let critique = await editorAgent.run(storyText);\n\n    while (critique !== 'Approved') {\n        storyText = applyCritique(storyText, critique); // Function using `diff`, LLM\n        critique = await editorAgent.run(storyText);\n    }\n    ```\n\n**2. Enhanced Chatbot Interactions:**\n\n* **Scenario:**  Customer support chatbot that handles complex inquiries by splitting them into sub-tasks.\n* **Applying the Paper:**\n    * **Specialized Agents:** A \"Problem Identifier\" agent (using NLP libraries like `compromise` or `natural`) breaks down user input. Other agents focus on specific problem types.\n    * **Collaboration:** Agents exchange information via a message queue (e.g., Redis, RabbitMQ). This mirrors the inter-agent communication in TRANSAGENTS.\n* **Example:**\n    ```javascript\n    // Hypothetical: Agent receives user input\n    const userInput = \"My order #123 is late, AND I want to change address for future ones\";\n\n    problemAgent.send(userInput); // Puts message on queue\n\n    // Other agents listening on the queue pick up relevant parts\n    ```\n\n**3. Collaborative Design and Coding:**\n\n* **Scenario:** A web-based tool where AI aids designers and coders working together.\n* **Applying the Paper:**\n    * **Design Agent:**  LLM-powered, using libraries like `p5.js` for visual output, proposes design elements.\n    * **Code Agent:**  Another agent translates the design into code (HTML, CSS, JavaScript).\n    * **Feedback Loop:**  A \"Project Manager\" agent (or human) provides feedback, guiding iterations like the Senior Editor in TRANSAGENTS.\n\n**Key Takeaways for JavaScript Developers:**\n\n* **Modularity:** Multi-agent systems break complexity into manageable parts. Think of your JS codebase this way, even if agents aren't full-fledged LLMs initially.\n* **Communication:** Experiment with inter-agent communication using existing JS tech (message queues, WebSockets).\n* **Evaluation:** Don't just rely on metrics. User preference and task-specific success are crucial.\n* **Progressive Enhancement:** Even simple agents with rule-based logic can be enhanced with LLMs over time.\n\nThis paper encourages JavaScript developers to think beyond monolithic LLMs. By embracing a multi-agent approach, we can build more robust, specialized, and truly collaborative web applications. \n",
  "pseudocode": "```javascript\n// Addition-by-Subtraction Collaboration Algorithm\nfunction additionBySubtractionCollaboration(context, instruction, maxIterations, additionAgent, subtractionAgent) {\n  let conversationHistory = [context, instruction];\n  let response = ''; \n  let currentRound = 0;\n\n  while (currentRound < maxIterations) {\n    currentRound++;\n    let detailedResponse = additionAgent(conversationHistory);\n    let feedback = subtractionAgent(conversationHistory, detailedResponse); \n    conversationHistory = conversationHistory.concat([detailedResponse, feedback]);\n\n    if (response === detailedResponse) {\n      break; // No further revisions needed\n    }\n    response = detailedResponse;\n  }\n  return response;\n}\n\n// Trilateral Collaboration Algorithm\nfunction trilateralCollaboration(context, instruction, maxIterations, actionAgent, critiqueAgent, judgmentAgent) {\n  let conversationHistory = [context, instruction];\n  let currentRound = 0;\n\n  while (currentRound < maxIterations) {\n    currentRound++;\n    let response = actionAgent(conversationHistory);\n    let critiques = critiqueAgent(conversationHistory, response); \n    conversationHistory = conversationHistory.concat([response, critiques]);\n\n    if (currentRound > 1) { // Judgment agent evaluates from the second round\n      let isResponseGood = judgmentAgent(context, instruction, response); \n      if (isResponseGood) {\n        break; // Stop if the judgment agent thinks the response is good enough\n      }\n    }\n  }\n  return response;\n}\n```\n\n**Explanation:**\n\n1. **`additionBySubtractionCollaboration`:**\n   - **Purpose:** This function simulates a collaborative process between two agents: an `additionAgent` responsible for generating a comprehensive response and a `subtractionAgent` for refining it by removing redundancy.\n   - **How it works:** \n      - It iteratively calls the `additionAgent` to produce a response based on the conversation history.\n      - The `subtractionAgent` then reviews this response, removing any redundant information.\n      - The process continues until the `subtractionAgent` finds no further revisions necessary or the maximum iterations are reached.\n\n2. **`trilateralCollaboration`:**\n   - **Purpose:** This function models collaboration among three agents: an `actionAgent` to generate a response, a `critiqueAgent` to provide feedback, and a `judgmentAgent` to assess the final response.\n   - **How it works:**\n      - It iteratively calls the `actionAgent` to generate a response.\n      - The `critiqueAgent` then analyzes the response and offers critiques.\n      - From the second round onwards, the `judgmentAgent` evaluates the response without needing the full conversation history.\n      - The process terminates when the `judgmentAgent` approves the response or the maximum iterations are reached.\n\nThese JavaScript functions represent the algorithmic logic described in the paper for multi-agent collaboration in literary translation. They provide a clear and functional translation of the original pseudocode, enabling software engineers to understand and implement these collaborative strategies in JavaScript-based multi-agent systems. \n",
  "simpleQuestion": "Can LLMs translate complex literature better than humans? \n",
  "timestamp": "2024-08-29T21:19:40.263Z"
}