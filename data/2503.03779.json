{
  "arxivId": "2503.03779",
  "title": "Accelerating Focal Search in Multi-Agent Path Finding with Tighter Lower Bounds",
  "abstract": "Abstract-Multi-Agent Path Finding (MAPF) involves finding collision-free paths for multiple agents while minimizing a cost function-an NP-hard problem. Bounded suboptimal methods like Enhanced Conflict-Based Search (ECBS) and Explicit Estimation CBS (EECBS) balance solution quality with computational efficiency using focal search mechanisms. While effective, traditional focal search faces a limitation: the lower bound (LB) value determining which nodes enter the FOCAL list often increases slowly in early search stages, resulting in a constrained search space that delays finding valid solutions. In this paper, we propose a novel bounded suboptimal algorithm, double-ECBS (DECBS), to address this issue by first determining the maximum LB value and then employing a best-first search guided by this LB to find a collision-free path. Experimental results demonstrate that DECBS outperforms ECBS in most test cases and is compatible with existing optimization techniques. DECBS can reduce nearly 30% high-level CT nodes and 50% low-level focal search nodes. When agent density is moderate to high, DECBS achieves a 23.5% average runtime improvement over ECBS with identical suboptimality bounds and optimizations.",
  "summary": "This paper introduces DECBS, an improved algorithm for Multi-Agent Path Finding (MAPF), the problem of finding collision-free paths for multiple agents.  DECBS optimizes the \"focal search\" process used in existing MAPF solvers by employing a two-phase \"double search.\" First, a shortest path search determines a maximum lower bound cost. Second, a best-first search uses this bound to find less collision-prone paths more efficiently.  This reduces both high-level planning and low-level pathfinding computation, especially in denser multi-agent scenarios.  While less impactful in sparse environments, the core idea of using pre-computed bounds for more efficient focal search could potentially be applied to other multi-objective optimization problems, possibly including those relevant to LLM-based multi-agent coordination and planning in web applications.",
  "takeaways": "This research paper presents valuable insights for JavaScript developers working with LLM-based multi-agent systems, particularly in web application development. Here's how a developer can apply these insights:\n\n**1. Optimizing LLM Agent Interactions in a Collaborative Web App:**\n\nImagine a web application for collaborative document editing where multiple LLM agents assist users with writing, formatting, and suggesting content.  Each agent can be viewed as an \"agent\" in the MAPF problem, and the document structure can be represented as a \"graph\". Conflicts arise when agents try to modify the same section simultaneously.  DECBS offers an optimization strategy to minimize such conflicts:\n\n* **JavaScript Implementation:** Use a library like `yjs` (for collaborative editing) coupled with a custom agent management system. Each agent's actions (e.g., text insertion, formatting change) can be treated as a \"move\" on the document graph.  Before an agent makes a change, the system can perform a \"double search\" similar to DECBS:\n    * **A* Search (Shortest Path):**  Quickly estimate the cost of applying the change, considering factors like potential conflicts with other agents' planned actions and the overall document coherence.\n    * **Best-First Search with Focal List:** Guided by the estimated cost from the A* search, perform a more detailed search for the least disruptive way to apply the change. Use a \"focal list\" to prioritize actions that minimize conflicts, similar to the collision minimization heuristic in DECBS.\n\n\n**2. Managing LLM Agents in a Virtual World:**\n\nConsider a web-based game or simulation with multiple LLM-controlled characters (agents) navigating a virtual environment. The DECBS approach can enhance the efficiency of path planning, reducing the computational cost of ensuring collision-free movement.\n\n* **JavaScript Implementation:** Utilize a JavaScript game engine like `Babylon.js` or `Three.js` and integrate an LLM agent controller.  When planning agent movements, employ a modified DECBS:\n    * **A* Search:**  Use A* to quickly estimate the shortest path for each agent, ignoring other agents initially.\n    * **Best-First Search with Focal List:**  Refine the paths using best-first search, considering the paths of other agents.  The \"focal list\" prioritizes paths that minimize collisions and maximize overall efficiency.\n\n\n**3. Coordinating LLM Agents in a Chat Application:**\n\nIn a group chat application with multiple LLM agents providing different services (e.g., translation, summarization, content generation), DECBS can coordinate their actions to minimize interruptions and maximize the flow of conversation.\n\n* **JavaScript Implementation:** Implement a message queue and a dispatcher that manages agent actions. The dispatcher can use DECBS principles:\n    * **A* Search:** Quickly assess the cost of each agent's action (e.g., generating a translation, providing a summary), considering the current conversation state.\n    * **Best-First Search with Focal List:** Prioritize agent actions that minimize interruptions and maximize the overall conversational coherence using a \"focal list\" sorted by a heuristic function.\n\n\n**4. Libraries and Frameworks:**\n\n* **LangChain:** Facilitates integrating LLMs into applications. It can be extended to implement DECBS-inspired agent management and coordination strategies.\n* **TensorFlow.js/ONNX.js:** Can be used to run smaller, optimized LLM models client-side for faster agent response times.\n* **Web Workers:**  Enable parallel processing of agent actions to improve responsiveness.\n\n\n**Key takeaways for JavaScript Developers:**\n\n* **Decoupling Search:** The \"double search\" concept allows for a faster, conflict-minimizing approach to agent action planning compared to traditional focal search.\n* **Lower-level search:** Can be simplified and accelerated by using a standard shortest path search algorithm (A*) followed by an optimized best-first search.\n* **Prioritization with Focal List:**  Use a \"focal list\" data structure to prioritize agent actions based on their estimated cost and potential for conflict, similar to the collision minimization heuristic in DECBS.\n\n\nBy adapting DECBS concepts to JavaScript and leveraging appropriate libraries, developers can build more efficient and robust LLM-based multi-agent web applications that better manage complex interactions, minimize conflicts, and improve user experience.",
  "pseudocode": "```javascript\nclass CTnode {\n  constructor() {\n    this.c = 0; // Cost of the solution\n    this.constraints = new Set(); // Set of constraints\n    this.paths = []; // Paths for each agent\n    this.lowerBounds = []; // Lower bounds for each agent's path\n    this.sumLowerBounds = 0; // Sum of lower bounds\n  }\n\n  hasCollision() {\n    // Implementation to check for collisions in this.paths\n    // ... (Collision detection logic based on the paths and graph)\n    // Returns true if a collision exists, false otherwise.\n    for (let agent1 = 0; agent1 < this.paths.length; agent1++) {\n      for (let agent2 = agent1 + 1; agent2 < this.paths.length; agent2++) {\n        // Check for collisions between agent1 and agent2 paths\n        // ... (Collision detection logic)\n           if (collisionDetected) return true;\n      }\n    }\n    return false;\n\n  }\n}\n\nfunction shortestPathSearch(graph, start, goal, constraints) {\n  // Implementation of A* search or similar algorithm\n  // considering the given constraints.\n  // Returns the optimal path cost.\n  // ... (A* search implementation)\n\n}\n\n\nfunction bestFirstSearch(graph, start, goal, constraints, w, optimalCost) {\n  // Implementation of best-first search guided by collision count\n  //  heuristic, using optimalCost as the upper bound.\n  // Returns the path cost.\n  // ... (Best-first search implementation)\n}\n\nfunction getFirstCollision(paths) {\n  // Implementation to detect the first collision in the given paths\n  // Returns the collision information (agents involved, time step).\n\n    for (let agent1 = 0; agent1 < paths.length; agent1++) {\n      for (let agent2 = agent1 + 1; agent2 < paths.length; agent2++) {\n        // Check for collisions between agent1 and agent2 paths\n        // ... (Collision detection logic)\n           if (collisionDetected) return {agent1, agent2, timestep};\n      }\n    }\n    return null; // No collision found.\n\n\n}\n\n\nfunction decbs(graph, startLocations, targetLocations, suboptimalityFactor) {\n  let H0 = new CTnode();\n  let focal = new PriorityQueue(); // Priority queue for focal list\n  let open = new PriorityQueue();  // Priority queue for open list\n\n  // Calculate heuristic for H0 (e.g., based on initial collisions)\n  // and insert H0 into OPEN list\n\n  focal.push(H0, priority);  // Example: use sum of lower bounds\n  open.push(H0, priority);    // Example: use sum of lower bounds\n\n while (!open.isEmpty()) {\n\n    let Hfront = open.peek(); \n    let newFocalNodes = []; \n    for(let h of open){\n        if(h.c <= suboptimalityFactor * Hfront.sumLowerBounds) { \n            newFocalNodes.push(h); \n            open.remove(h);\n        } else break; \n    }\n    focal.push(newFocalNodes); \n\n\n    let Hcur = focal.pop();\n\n    if (!Hcur.hasCollision()) {\n      return Hcur.paths;\n    }\n\n\n    let collision = getFirstCollision(Hcur.paths);\n    let [agentI, agentJ, timestep] = collision;\n\n    for (let agentK of [agentI, agentJ]) { // corrected loop.\n      let Q = structuredClone(Hcur); // Deep copy of Hcur\n\n      if (/* vertex collision */) {\n        Q.constraints.add({ agent: agentK, vertex: collision.v, time: timestep});\n      } else {\n        Q.constraints.add({ agent: agentK, edge: {u:collision.u,v: collision.v}, time: timestep });\n      }\n\n      let [lowerBound, pathCost] = lowLevelSearch(graph, startLocations[agentK], targetLocations[agentK], Q, suboptimalityFactor);\n       if (lowerBound !== Infinity){ //if the path exists, push it to open list\n        Q.c = pathCost; \n        Q.lowerBounds[agentK] = lowerBound;\n        Q.sumLowerBounds = Q.lowerBounds.reduce((sum, lb) => sum + lb, 0);\n      // Calculate heuristic for Q (e.g., collision count)\n       open.push(Q, priority)\n\n       }\n\n\n\n\n    }\n  }\n  return \"No valid solution\";\n}\n\nfunction lowLevelSearch(graph, start, goal, ctNode, w) {\n  let optimalCost = shortestPathSearch(graph, start, goal, ctNode.constraints);\n  let pathCost = bestFirstSearch(graph, start, goal, ctNode.constraints, w, optimalCost);\n  return [optimalCost, pathCost]; \n}\n\n\n\n\n```\n\n**Explanation:**\n\nThe provided pseudocode describes the **DECBS (double-ECBS)** algorithm for multi-agent pathfinding.  It's a bounded suboptimal algorithm based on ECBS but improves low-level search efficiency.\n\n1. **`DECBS(G, {si}, {gi}, w)`:** This is the main function.\n    - Takes the graph `G`, start locations `{si}`, goal locations `{gi}`, and suboptimality factor `w` as input.\n    - Initializes a `CTnode` (Constraint Tree node) `H0` with no constraints.\n    - Uses priority queues `FOCAL` and `OPEN` to manage the search, prioritized by cost and a heuristic function `d(H)`.\n    - Iteratively expands nodes from `FOCAL` until a collision-free solution is found or the `OPEN` list is empty.\n    - `getFirstCollision()` detects collisions in a solution.\n    - Constraints are added based on detected collisions, and `lowLevelSearch()` is called to find paths for individual agents satisfying the constraints.\n    - If a valid solution is found, it's returned; otherwise, \"No valid solution\" is returned.\n\n\n2. **`lowLevelSearch(G, sk, gk, Q, w)`:** This function handles the \"double search\" aspect of DECBS.\n    - Takes the graph `G`, start `sk`, goal `gk`, current CT node `Q`, and suboptimality factor `w` as input.\n    - **First Search (Shortest Path):** Calls `shortestPathSearch()` to find the optimal path cost `c*` for the agent under the given constraints using A* search.\n    - **Second Search (Best-First):** Calls `bestFirstSearch()`, a best-first search guided by a heuristic (e.g., collision count), using `w * c*` as an upper bound, to find a suboptimal path that might have fewer collisions.\n    - Returns both the optimal cost `c*` (used as a lower bound) and the actual cost of the found suboptimal path.\n\n**Key Improvements over ECBS:**\n\n- **Tighter Lower Bound:** By finding the optimal path cost in the first search of `lowLevelSearch()`, DECBS uses a tighter lower bound for pruning the search space compared to ECBS, which uses the minimum cost in the `OPEN` list. This leads to a smaller search space and faster convergence.\n\n- **Better Heuristic Guidance:** Using the optimal cost also allows more nodes to enter the `FOCAL` list, giving the best-first search a better chance of finding paths with fewer collisions and reducing the number of high-level CT nodes expanded.\n\n- **Balanced Search:** Addresses the issue in ECBS where the lower bound increases slowly, leading to unbalanced search tree expansion, particularly in the early stages.\n\n\nThis JavaScript code provides a more structured and implementable version of the DECBS algorithm.  It uses classes and functions to organize the logic, includes necessary data structures like priority queues and sets, and replaces pseudocode placeholders with comments explaining where the specific implementations of search algorithms and collision detection would go.  This makes the code closer to a functional implementation that a JavaScript developer could use as a starting point for building a real multi-agent pathfinding system.",
  "simpleQuestion": "How can I speed up multi-agent pathfinding?",
  "timestamp": "2025-03-07T06:03:08.108Z"
}