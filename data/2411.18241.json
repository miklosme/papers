{
  "arxivId": "2411.18241",
  "title": "Exploration of LLM Multi-Agent Application Implementation Based on LangGraph+CrewAI",
  "abstract": "Abstract-With the rapid development of large model technology, the application of agent technology in various fields is becoming increasingly widespread, profoundly changing people's work and lifestyles. In complex and dynamic systems, multi-agents achieve complex tasks that are difficult for a single agent to complete through division of labor and collaboration among agents. This paper discusses the integrated application of LangGraph and CrewAI. LangGraph improves the efficiency of information transmission through graph architecture, while CrewAI enhances team collaboration capabilities and system performance through intelligent task allocation and resource management. The main research contents of this paper are: (1) designing the architecture of agents based on LangGraph for precise control; (2) enhancing the capabilities of agents based on CrewAI to complete a variety of tasks. This study aims to delve into the application of LangGraph and CrewAI in multi-agent systems, providing new perspectives for the future development of agent technology, and promoting technological progress and application innovation in the field of large model intelligent agents.",
  "summary": "This paper explores using LangGraph and CrewAI to build multi-agent systems with large language models (LLMs). LangGraph manages workflow and communication, while CrewAI handles task allocation and agent collaboration.  Key aspects for LLM-based multi-agent systems include: using LangGraph for structured workflows and precise control of LLMs,  leveraging CrewAI for defining roles, automating tasks, and optimizing teamwork between LLMs, and combining these frameworks to build more efficient and scalable applications, exemplified by automatic email handling and code generation/review scenarios.",
  "takeaways": "This paper introduces the combined use of LangGraph and CrewAI for building multi-agent systems, offering several opportunities for JavaScript developers working with LLMs. Here's how a JavaScript developer can apply these insights:\n\n**1. Building Conversational Agents with Role-Playing and Task Delegation:**\n\n* **Scenario:** Develop a customer support chatbot system where multiple agents handle different aspects of a customer's request.\n* **Implementation:**\n    * Use LangChain.js for interacting with LLMs.\n    * Implement a \"Crew\" using a JavaScript class to manage agents.  Each agent (an instance of the class) would have a specific role (e.g., \"OrderStatusAgent,\" \"BillingAgent,\" \"TechnicalSupportAgent\").\n    * Define tasks as JavaScript functions. CrewAI's concept of task delegation can be implemented by having the \"Crew\" object assign tasks to appropriate agents based on the customer's input.\n    * Use LangGraph's principles for structuring the conversation flow.  This could involve creating a state machine in JavaScript to manage the dialogue state and transitions between agents.\n\n\n**2. Collaborative Content Creation:**\n\n* **Scenario:**  A web application where multiple LLM agents collaborate to write different sections of an article, generate marketing copy, or create other forms of content.\n* **Implementation:**\n    * Create a central \"Crew\" to manage agent collaboration.\n    * Assign each agent a specific role (e.g., \"IntroductionWriter,\" \"BodyWriter,\" \"ConclusionWriter\").\n    * Use LangGraph to define the workflow (e.g., Introduction -> Body -> Conclusion).\n    * LangChain.js can be used to interact with the LLMs, and the outputs of each agent can be combined in the web application.\n\n\n**3.  Automating Complex Web Workflows:**\n\n* **Scenario:**  Automating tasks like website testing, content moderation, or user onboarding.\n* **Implementation:**\n    * Define agents for each step in the workflow (e.g., \"ContentCrawler,\" \"ToxicityDetector,\" \"WelcomeEmailSender\").\n    * Use LangGraph to define the workflow and manage state transitions.\n    * Employ libraries like Puppeteer for web scraping and interaction in the \"ContentCrawler\" agent.\n    * Integrate with third-party APIs for toxicity detection or email sending through respective agents.\n\n\n**4.  Personalized Recommendation Systems:**\n\n* **Scenario:**  A web application that provides personalized product or content recommendations.\n* **Implementation:**\n    * Define agents with roles like \"PreferenceLearner,\" \"ProductRecommender,\" \"ContentFilter.\"\n    * \"PreferenceLearner\" interacts with the user to understand their preferences using natural language processing via LangChain.js.\n    * \"ProductRecommender\" and \"ContentFilter\" agents leverage the learned preferences to make recommendations using relevant algorithms.\n    * LangGraph manages the flow between these agents.\n\n\n**JavaScript Libraries and Frameworks:**\n\n* **LangChain.js:**  For connecting to LLMs and managing prompts.\n* **State Machine Libraries:**  Xstate or Machina.js can be used to implement LangGraph's workflow management concepts in the browser or on the server.\n* **Node.js:** Server-side JavaScript runtime for building the backend logic of your multi-agent system.\n* **WebSockets:**  For real-time communication between agents and the client-side web application.\n* **Frontend Frameworks (React, Vue, Angular):** To build the user interface and visualize the agent interactions.\n\n\n**Key Considerations for JavaScript Developers:**\n\n* **Asynchronous Programming:**  Multi-agent systems involve concurrent operations. JavaScript's async/await and Promises are essential for managing these asynchronous interactions.\n* **State Management:**  Keeping track of the state of each agent and the overall system is crucial. Use appropriate state management solutions in your chosen framework.\n* **Error Handling:**  Implement robust error handling mechanisms to ensure the system's resilience.\n* **Scalability:**  Consider how your multi-agent system will scale as the number of agents and interactions grows.\n\n\n\nBy combining the conceptual framework of LangGraph and CrewAI with the practical tools available in the JavaScript ecosystem, developers can build powerful and sophisticated LLM-based multi-agent applications for the web. Remember to start with a well-defined scope and iteratively develop your system, experimenting with different agent architectures and workflows to achieve the desired functionality.",
  "pseudocode": "The provided research paper uses code examples instead of pseudocode to illustrate the concepts. The code examples are already in Python, so they need to be translated to JavaScript.  Here are the translated snippets and explanations:\n\n**Figure 2:  Workflow Definition with LangGraph (Python to JavaScript)**\n\n```python\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom langgraph.graph import StateGraph\nfrom.state import EmailsState\nfrom.nodes import Nodes\nfrom.crew.crew import EmailFilterCrew\n\nclass WorkFlow():\n    def __init__(self):\n        nodes = Nodes()\n        workflow = StateGraph(EmailsState)\n        workflow.add_node(\"check_new_emails\", nodes.check_email)\n        workflow.add_node(\"wait_next_run\", nodes.wait_next_run)\n        workflow.add_node(\"draft_responses\", EmailFilterCrew().kickoff)\n        workflow.set_entry_point(\"check_new_emails\")\n        workflow.add_conditional_edges(\n            \"check_new_emails\",\n            nodes.new_emails,\n            {\n                \"continue\": 'draft_responses',\n                \"end\": 'wait_next_run'\n            }\n        )\n        workflow.add_edge('draft_responses', 'wait_next_run')\n        workflow.add_edge('wait_next_run', 'check_new_emails')\n        self.app = workflow.compile()\n```\n\n```javascript\n// Assuming LangGraph and CrewAI equivalent functionalities are available in JavaScript.\n// Replace with actual library/package imports.\n// Mock implementations for demonstration.\nclass StateGraph { /* ... */ };\nclass EmailsState { /* ... */ };\nconst Nodes = () => ({ check_email: () => {}, wait_next_run: () => {}, new_emails: () => {} });\nconst EmailFilterCrew = () => ({ kickoff: () => {} });\n\n\nclass Workflow {\n  constructor() {\n    const nodes = Nodes();\n    const workflow = new StateGraph(new EmailsState());\n    workflow.addNode(\"check_new_emails\", nodes.check_email);\n    workflow.addNode(\"wait_next_run\", nodes.wait_next_run);\n    workflow.addNode(\"draft_responses\", EmailFilterCrew().kickoff);\n    workflow.setEntryPoint(\"check_new_emails\");\n    workflow.addConditionalEdges(\n      \"check_new_emails\",\n      nodes.new_emails,\n      {\n        continue: 'draft_responses',\n        end: 'wait_next_run'\n      }\n    );\n    workflow.addEdge('draft_responses', 'wait_next_run');\n    workflow.addEdge('wait_next_run', 'check_new_emails');\n    this.app = workflow.compile(); // Assuming a compile method exists.\n  }\n}\n\nconst workflow = new Workflow();\n\n\n```\n\n*Explanation:* This code defines the workflow for an email processing agent using LangGraph. It creates a state graph, adds nodes representing different actions (check emails, draft responses, wait), and defines transitions between these nodes based on conditions (e.g., if new emails exist). This demonstrates LangGraph's ability to define complex, conditional workflows.  It assumes that a JavaScript implementation of `langGraph` and `crewAI` frameworks are available. Placeholder implementations of some functions and classes are given, and you'll need to substitute those with actual library calls if such libraries exist.\n\n**Figures 3 and 4: Agent and Task Definition with CrewAI (Python to JavaScript)**\n\n```python\nclass EmailFilterAgents():\n    def __init__(self):\n        self.gmail = GmailToolkit()  # Assuming GmailToolkit exists\n\n    def email_filter_agent(self):\n        return Agent(\n            role='Senior Email Analyst',\n            goal='Filter out non-essential emails ...',\n            backstory=dedent(\"\"\"...\"\"\"),\n            verbose=True,\n            allow_delegation=False\n        )\n\nclass EmailFilterTasks:\n    def filter_emails_task(self, agent, emails):\n        return Task(\n            description=dedent(f\"\"\"... {emails} ...\"\"\"),\n            agent=agent\n        )\n```\n\n```javascript\n// Mock implementations.  Replace with real library/framework calls.\nclass Agent { constructor(options) { /* ... */ } };\nclass Task { constructor(options) { /* ... */ } };\n// Mock GmailToolkit\nconst GmailToolkit = () => ({});  \n\nclass EmailFilterAgents {\n    constructor() {\n        this.gmail = GmailToolkit();\n    }\n\n    emailFilterAgent() {\n        return new Agent({\n            role: 'Senior Email Analyst',\n            goal: 'Filter out non-essential emails ...',\n            backstory: `...`, // Multi-line string\n            verbose: true,\n            allowDelegation: false\n        });\n    }\n}\n\nclass EmailFilterTasks {\n    filterEmailsTask(agent, emails) {\n        return new Task({\n            description: `... ${emails} ...`, // Using template literals for multi-line strings\n            agent: agent\n        });\n    }\n}\n\n\nconst emailFilterAgents = new EmailFilterAgents();\nconst emailFilterTasks = new EmailFilterTasks();\n\nconst agent = emailFilterAgents.emailFilterAgent();\nconst task = emailFilterTasks.filterEmailsTask(agent, /* emails array */);\n\n```\n\n*Explanation:* This code demonstrates how to define an agent and a task using CrewAI. The `EmailFilterAgent` class defines an agent with a specific role, goal, and backstory. The `EmailFilterTasks` class defines a task for filtering emails, assigning it to the defined agent.  This highlights CrewAI's ability to create specialized agents and assign them specific tasks, fostering multi-agent collaboration.  Similar to the previous example, placeholder implementations are given, and you should replace these with actual library/framework calls when they are available.\n\n\nThese JavaScript translations provide a starting point for JavaScript developers to experiment with the concepts presented in the paper. Remember to replace the placeholder implementations with actual calls to LangGraph and CrewAI libraries (or their conceptual equivalents in JavaScript) once they become more readily available for web development.",
  "simpleQuestion": "How can LangGraph+CrewAI improve LLM multi-agent apps?",
  "timestamp": "2024-11-28T06:02:04.884Z"
}