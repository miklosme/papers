{
  "arxivId": "2410.22662",
  "title": "EMOS: Embodiment-Aware Heterogeneous Multi-Robot Operating System with LLM Agents",
  "abstract": "Heterogeneous multi-robot systems (HMRS) have emerged as a powerful approach for tackling complex tasks that single robots cannot manage alone. Current large-language-model-based multi-agent systems (LLM-based MAS) have shown success in areas like software development and operating systems, but applying these systems to robot control presents unique challenges. In particular, the capabilities of each agent in a multi-robot system are inherently tied to the physical composition of the robots, rather than predefined roles. To address this issue, we introduce a novel multi-agent framework designed to enable effective collaboration among heterogeneous robots with varying embodiments and capabilities, along with a new benchmark named Habitat-MAS. One of our key designs is Robot Resume: Instead of adopting human-designed role play, we propose a self-prompted approach, where agents comprehend robot URDF files and call robot kinematics tools to generate descriptions of their physics capabilities to guide their behavior in task planning and action execution. The Habitat-MAS benchmark is designed to assess how a multi-agent framework handles tasks that require embodiment-aware reasoning, which includes 1) manipulation, 2) perception, 3) navigation, and 4) comprehensive multi-floor object rearrangement. The experimental results indicate that the robot's resume and the hierarchical design of our multi-agent system are essential for the effective operation of the heterogeneous multi-robot system within this intricate problem context.",
  "summary": "This paper introduces EMOS, a new framework for controlling teams of different robots (like drones, wheeled robots, and legged robots) using a team of large language model (LLM) agents.  Instead of pre-assigning roles to each robot, EMOS has each LLM agent read the robot's design file (URDF) to understand its physical capabilities, creating a \"robot resume.\"  The agents then discuss and plan how to complete a task, assigning subtasks based on each robot's strengths. This approach is tested in a new simulated environment called Habitat-MAS, which includes multi-floor homes and challenges like navigation, object manipulation, and perception. Results show that understanding the robots' physical abilities, through the robot resume, significantly improves the system's performance.",
  "takeaways": "This paper introduces EMOS, a framework for managing heterogeneous multi-robot systems using LLM-based agents. While the paper focuses on robotics, the core concepts of embodiment-aware reasoning, task planning, and decentralized action execution are highly relevant to web development, particularly for complex multi-agent applications leveraging LLMs. Here are some practical examples for JavaScript developers:\n\n**1. Embodiment-Aware LLMs for Personalized Web Experiences:**\n\nImagine building a website with multiple LLM-powered agents, each responsible for different aspects of user interaction (e.g., customer support, product recommendations, content generation).  Instead of assigning fixed roles, you can implement \"agent resumes\"  in JavaScript objects. These resumes would define the agent's capabilities (e.g., access to specific databases, proficiency in certain languages, knowledge domains).\n\n```javascript\n// Agent Resume Example\nconst customerSupportAgent = {\n  name: \"SupportBot\",\n  capabilities: {\n    languages: [\"English\", \"Spanish\"],\n    knowledgeDomain: \"productInfo\",\n    access: [\"customerDatabase\", \"FAQdatabase\"]\n  }\n};\n\n// Task Assignment Logic\nfunction assignTask(task, agents) {\n  // Use agent resumes to filter suitable agents.\n  const eligibleAgents = agents.filter(agent => \n    agent.capabilities.knowledgeDomain === task.domain &&\n    agent.capabilities.languages.includes(task.language)\n  );\n\n  // Select an agent based on availability, workload, etc.\n  // ...\n}\n```\n\n**2. Decentralized Action Execution with Web Workers:**\n\nThe paper's emphasis on decentralized action execution translates well to web development.  You can use Web Workers to create independent agents that execute actions asynchronously, improving responsiveness and scalability. Each worker can encapsulate an LLM agent and its associated logic.\n\n```javascript\n// Web Worker Example\nconst worker = new Worker('agentWorker.js');\n\n// Send task to worker\nworker.postMessage({ task: 'generateContent', data: { topic: 'AI' } });\n\n// Receive results from worker\nworker.onmessage(event => {\n    console.log('Content generated:', event.data.content);\n});\n```\n\n**3. Hierarchical Task Planning with LangChain:**\n\nLangChain is a powerful JavaScript framework ideal for implementing hierarchical task planning with LLMs. You can use it to create chains of actions, where higher-level agents break down complex tasks into subtasks and assign them to specialized lower-level agents based on their resumes.\n\n```javascript\n// LangChain Example (Conceptual)\nconst plannerAgent = new LLM({ /* ... */ });\nconst workerAgents = [ /* ... agent instances with resumes ... */ ];\n\n// Planner agent decomposes the task\nconst subtasks = await plannerAgent.call({ input: \"Write a blog post about AI\" });\n\n// Assign subtasks to worker agents based on their resumes\nsubtasks.forEach(subtask => {\n  const assignedAgent = assignTask(subtask, workerAgents);\n  assignedAgent.execute(subtask);\n});\n```\n\n\n**4.  Multi-agent Communication with a Message Broker:**\n\nFor complex multi-agent web apps, consider using a message broker like Redis or RabbitMQ for inter-agent communication.  Agents can publish updates and subscribe to relevant topics, facilitating coordination without direct coupling. This mirrors the decentralized communication pattern advocated in the paper.\n\n\n**5.  Experimenting with Agent Resumes:**\n\nStart simple. Define agent resumes as JSON objects with capabilities. Experiment with different matching algorithms to assign tasks based on agent resumes. You could simulate different agent workloads and capabilities to see how it affects task completion and resource utilization. LangChain's modularity makes it a good starting point for such experiments.\n\n\nBy adopting these principles, JavaScript developers can build more sophisticated, robust, and scalable LLM-based multi-agent applications for the web, drawing inspiration from cutting-edge research in robotics and AI. This will open doors for creating truly dynamic and interactive web experiences that go beyond current capabilities.",
  "pseudocode": "```javascript\n// JavaScript translation of Algorithm 1: Hierarchical Task Planning, Assignment, and Action in a Multi-Agent System\n\nasync function hierarchicalTaskPlanning(robots, robotResumes, task) {\n  // Stage 1: Centralized Group Discussion\n  const subtasks = {};\n  for (const robot of robots) {\n    subtasks[robot.id] = await centralPlanner(task, robotResumes[robot.id]);\n    let feedback = await reflection(subtasks[robot.id], robotResumes[robot.id]);\n    while (feedback.invalid) {\n      // Reassign subtask based on feedback (implementation not provided in original pseudocode)\n      subtasks[robot.id] = await centralPlanner(task, robotResumes[robot.id]); //  Simplified reassignment, could be more sophisticated\n      feedback = await reflection(subtasks[robot.id], robotResumes[robot.id]);\n    }\n  }\n\n\n  // Stage 2: Decentralized Action Execution\n  const histories = {};\n  const taskFinishedPromises = robots.map(robot => { // create promises for each robot\n    return new Promise(async resolve => { // resolves when individual robot is finished\n      histories[robot.id] = [];\n      while (!(await taskFinished(robot, subtasks[robot.id]))) {\n        const action = await functionCall(robot, subtasks[robot.id], histories[robot.id]);\n        const response = await executeAction(robot, action);\n        histories[robot.id] = [...histories[robot.id], action, response];\n      }\n      if (await taskFinished(robot, subtasks[robot.id])) {\n        await waitState(robot);\n        resolve()\n      }\n    })\n  })\n  await Promise.all(taskFinishedPromises) // wait for all the robots to finish their tasks.\n  return \"Done\";\n}\n\n// Placeholder functions (implementation would be environment and task specific)\nasync function centralPlanner(task, robotResume) { /* ... */ return { /* subtask details */ }; }\nasync function reflection(subtask, robotResume) { /* ... */ return { invalid: false }; }\nasync function taskFinished(robot, subtask) { /* ... */ return true; } \nasync function functionCall(robot, subtask, history) { /* ... */ return { /* action details */ }; }\nasync function executeAction(robot, action) { /* ... */ return { /* execution results */ }; }\nasync function waitState(robot) { /* ... */ }\n\n\n\n// Example usage (Illustrative):\nconst robots = [{ id: 'robot1' }, { id: 'robot2' }];\nconst robotResumes = {\n  robot1: { /* ... robot1 resume data ... */ },\n  robot2: { /* ... robot2 resume data ... */ }\n};\nconst task = \"Pick and place objects\";\n\n\nhierarchicalTaskPlanning(robots, robotResumes, task).then((result)=>{\n  console.log(result)\n})\n\n\n\n\n```\n\n\n\n**Explanation:**\n\nThis JavaScript code implements a hierarchical task planning, assignment, and action execution system for a multi-agent robotic environment, mirroring the original pseudocode. It simulates the interaction of multiple robots with varying capabilities to accomplish a given task.\n\n**Algorithm Purpose:**\n\nThe algorithm aims to automate the coordination of heterogeneous multi-robot systems (HMRS).  It breaks down complex tasks into subtasks, assigns them to suitable robots considering their \"resumes\" (capabilities), and manages action execution while allowing for feedback and reassignment.  It addresses the challenge of efficiently utilizing diverse robot skills in a shared environment.\n\n**Key Concepts:**\n\n1. **Robot Resume:** A data structure encapsulating the capabilities of each robot (mobility, perception, manipulation).\n\n2. **Centralized Group Discussion:** A synchronized stage where a central planner initially allocates subtasks to robots. Robots then provide feedback on the feasibility based on their capabilities.\n\n3. **Decentralized Action Parallel Execution:** An asynchronous stage where robots execute their assigned subtasks in parallel, interacting with the environment and updating their histories.\n\n4. **Hierarchical Structure:** The two-stage approach (Centralized Discussion followed by Decentralized Execution) allows for initial coordination and subsequent independent action.\n\n**Improvements in the JavaScript code**:\n\n* **Asynchronous operations:** The decentralized action execution phase uses promises and `async/await` to properly handle the parallel execution of actions, mirroring the asynchronous nature of the robot operations.\n* **Error Handling and Reassignment Logic:** Added a `while` loop during the centralized discussion stage to handle potential reassignments of subtasks. This addresses situations where feedback indicates a subtask is not feasible for the assigned robot.\n* **Modular Structure:** The code is broken down into functions to improve readability and maintainability. This makes it easier to understand the different components of the algorithm and to modify or extend them as needed.\n\n\n\n**Note:** The provided JavaScript code maintains the structure and logic of the original pseudocode. However, the placeholder functions (`centralPlanner`, `reflection`, `taskFinished`, `functionCall`, `executeAction`, `waitState`) need to be implemented with specific logic based on the environment, robot capabilities, and task requirements. These functions would typically involve interaction with a robot simulator or real-world robot interfaces, and the implementation details would be highly environment and task-specific.",
  "simpleQuestion": "How to make robots work together using LLMs?",
  "timestamp": "2024-10-31T06:01:23.165Z"
}