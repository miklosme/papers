{
  "arxivId": "2410.02189",
  "title": "AGENT-ORIENTED PLANNING IN MULTI-AGENT SYSTEMS",
  "abstract": "Through the collaboration of multiple agents possessing diverse expertise and tools, multi-agent systems achieve impressive progress in solving real-world problems. Given the user queries, the meta-agents, serving as the brain within these systems, are required to decompose the queries into multiple sub-tasks that can be allocated to suitable agents capable of solving them, so-called agent-oriented planning. In this study, we identify three critical design principles of agent-oriented planning, including solvability, completeness, and non-redundancy, to ensure that each sub-task is effectively resolved, leading to satisfactory responses to the original queries. These principles further inspire us to propose a novel framework for agent-oriented planning in multi-agent systems, leveraging a fast task decomposition and allocation process followed by an effective and efficient evaluation via a reward model. During the planning process, the meta-agent is also responsible for evaluating the performance of the expert agents, making timely adjustments to the sub-tasks and scheduling as necessary. Besides, we integrate a feedback loop into the proposed framework to further enhance the effectiveness and robustness of such a problem-solving process. Extensive experiments demonstrate the advancement of the proposed framework in solving real-world problems compared to both single-agent systems and existing planning strategies for multi-agent systems.",
  "summary": "This research paper proposes a framework for agent-oriented planning in multi-agent AI systems. The framework breaks down user queries into smaller sub-tasks and assigns them to specialized AI agents (like code or search agents) for execution.\n\nKey points for LLM-based multi-agent systems:\n\n* **Efficient task allocation:**  A reward model predicts which agents are best suited for each sub-task, minimizing unnecessary agent calls.\n* **Task modification mechanisms:**  The system refines sub-tasks based on their complexity and the agent's capabilities, including replanning, detailing, or re-describing them.\n* **Completeness and non-redundancy:** A dedicated component analyzes sub-tasks to ensure they collectively cover the user query without redundant information.\n* **Continuous learning:** The system incorporates feedback from completed tasks to improve future task decomposition and agent selection.",
  "takeaways": "This paper introduces a framework for agent-oriented planning in multi-agent systems, a particularly relevant topic for JavaScript developers diving into LLM-powered applications. Here's how a JavaScript developer can apply these insights:\n\n**1. Building a Reward Model for Sub-Task Solvability:**\n\n* **Scenario:** Imagine you're building a multi-agent web app for travel planning. You have agents specializing in flights, hotels, and activities.\n* **Implementation:**  Train a reward model using a JavaScript machine learning library like TensorFlow.js. This model would take a sub-task (e.g., \"find a hotel in Paris\") and an agent description (e.g., \"hotel booking agent\") as input and predict the quality of the potential response.\n* **Practical Example:** \n   ```javascript\n   // Assuming you have a trained TensorFlow.js model named 'rewardModel'\n   async function predictSubtaskSolvability(subtask, agentDescription) {\n       const prediction = await rewardModel.predict(preprocessInput(subtask, agentDescription));\n       // ... logic to interpret the prediction and decide sub-task solvability \n   }\n   ```\n\n**2. Representative Works for Sub-Task Modification:**\n\n* **Scenario:** Your travel app encounters a sub-task like \"find pet-friendly accommodation in Rome,\" which the 'hotel booking agent' struggles with.\n* **Implementation:** Store successful past sub-tasks as \"representative works\" for each agent. Use a JavaScript framework like Node.js with a database (e.g., MongoDB) to manage these.  Compare new sub-tasks to representative works using cosine similarity (easily calculated with libraries like `mathjs`). \n* **Practical Example:**\n   ```javascript\n   // Assuming you have a 'representativeWorks' collection in your MongoDB database\n   async function findSimilarSubtasks(newSubtask, agentId) {\n       const similarTasks = await representativeWorks.find({\n           agentId: agentId,\n           embedding: { $near: { $geometry: getEmbedding(newSubtask) } }\n       });\n       // ... logic to use similar tasks for sub-task modification (re-describe or plan-in-detail)\n   }\n   ```\n\n**3. Detector for Completeness and Non-Redundancy:**\n\n* **Scenario:** The meta-agent creates sub-tasks: \"find flights to Tokyo,\" \"book a hotel near the airport,\" and \"find a good sushi restaurant.\" The detector needs to identify redundancy.\n* **Implementation:**  Build a detector function using a JavaScript LLM library like `langchain`.  This function would analyze sub-tasks, flag redundancy (e.g., \"find a good sushi restaurant\" is likely covered by \"book a hotel near the airport\"), and suggest combining or removing sub-tasks.\n* **Practical Example:**\n   ```javascript\n   // Assuming you have a Langchain chain for the detector \n   async function detectRedundancy(subtasks) {\n       const analysis = await detectorChain.call({ subtasks: JSON.stringify(subtasks) });\n       if (analysis.redundancy) {\n           // ... logic to modify the sub-tasks based on the detector's suggestions\n       }\n   }\n   ```\n\n**4. Feedback Loop for Meta-Agent Improvement:**\n\n* **Scenario:** After booking a trip, the user provides feedback that the hotel was too far from the city center. \n* **Implementation:** Integrate a feedback mechanism in your web app using a JavaScript framework like React. User feedback can be used to update the reward model, refine representative works, and improve the meta-agent's planning. \n* **Practical Example:**\n   ```javascript\n   // React component to collect feedback\n   function FeedbackForm() {\n       // ... logic to collect and submit feedback\n   }\n   ```\n\n**Key JavaScript Technologies:**\n\n* **LLM Libraries:** `langchain`, `transformers.js` (for interacting with LLMs)\n* **Machine Learning Libraries:** TensorFlow.js, Brain.js\n* **Backend Frameworks:** Node.js, Express.js\n* **Databases:** MongoDB, PostgreSQL\n* **Frontend Frameworks:** React, Vue.js\n\n**By implementing these concepts, JavaScript developers can create more intelligent and robust LLM-based multi-agent applications for a variety of web development scenarios.**",
  "pseudocode": "No pseudocode block found.",
  "simpleQuestion": "How to plan tasks for LLM agents?",
  "timestamp": "2024-10-04T05:04:04.597Z"
}