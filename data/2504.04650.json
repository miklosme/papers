{
  "arxivId": "2504.04650",
  "title": "Autono: A ReAct-Based Highly Robust Autonomous Agent Framework",
  "abstract": "This paper proposes a highly robust autonomous agent framework based on the ReAct paradigm, designed to solve complex tasks through adaptive decision making and multi-agent collaboration. Unlike traditional frameworks that rely on fixed workflows generated by LLM-based planners, this framework dynamically generates next actions during agent execution based on prior trajectories, thereby enhancing its robustness. To address potential termination issues caused by adaptive execution paths, I propose a timely abandonment strategy incorporating a probabilistic penalty mechanism. For multi-agent collaboration, I introduce a memory transfer mechanism that enables shared and dynamically updated memory among agents. The framework's innovative timely abandonment strategy dynamically adjusts the probability of task abandonment via probabilistic penalties, allowing developers to balance conservative and exploratory tendencies in agent execution strategies by tuning hyperparameters. This significantly improves adaptability and task execution efficiency in complex environments. Additionally, agents can be extended through external tool integration, supported by modular design and MCP protocol compatibility, which enables flexible action space expansion. Through explicit division of labor, the multi-agent collaboration mechanism enables agents to focus on specific task components, thereby significantly improving execution efficiency and quality.",
  "summary": "This paper introduces Autono, a new framework for building robust, multi-agent AI systems for complex tasks.  It uses the ReAct (Reasoning + Acting) paradigm, allowing agents to dynamically adapt their actions based on past experiences and real-time feedback.\n\nKey features for LLM-based multi-agent systems include: dynamic action generation, a \"timely abandonment\" strategy to prevent agents from getting stuck on unproductive tasks, a memory sharing mechanism for collaboration, and compatibility with the Model Context Protocol (MCP) for standardized communication with external tools and LLMs.  These features aim to improve robustness, flexibility, and efficiency compared to existing frameworks like LangChain and AutoGen.",
  "takeaways": "This paper presents intriguing concepts applicable to JavaScript developers building LLM-powered multi-agent web apps. Let's break down practical examples leveraging its insights:\n\n**1. ReAct-based Action Strategy (Algorithm 1):**\n\n* **Scenario:** A multi-agent chatbot for customer support. One agent handles initial queries, another specializes in technical issues, and a third handles billing.\n* **JavaScript Implementation:**\n    * Use LangChain.js or similar libraries to interface with LLMs.\n    * Represent \"tools\" as JavaScript functions. For example, `getTechnicalDocs(query)`, `processPayment(details)`, `escalateToHuman()`.\n    * The \"trajectory\" can be an array of previous agent actions and LLM outputs.\n    * Implement Algorithm 1 in JavaScript to select the next action (tool) based on the current state (trajectory) and user request. Example:\n\n```javascript\nfunction getNextAction(trajectory, userRequest, tools) {\n  // ... (Algorithm 1 logic) analyze trajectory and user request ...\n\n  if (userRequest.includes(\"technical\")) {\n    return { tool: tools.getTechnicalDocs, args: { query: userRequest } };\n  } else if (userRequest.includes(\"payment\")) {\n    return { tool: tools.processPayment, args: { /* ... */ } };\n  } // ... other conditions ...\n}\n```\n\n**2. Timely Abandonment Strategy (Algorithm 2):**\n\n* **Scenario:**  An agent generates code based on user prompts. Prevent infinite loops or overly complex code generation attempts.\n* **JavaScript Implementation:**\n    * Use a `stepCounter` variable to track agent actions.\n    * Estimate maximum steps (`s`) using a heuristic or previous task data.\n    * Implement Algorithm 2 to conditionally abandon a task:\n\n```javascript\nlet stepCounter = 0;\nconst maxSteps = estimateMaxSteps(userPrompt);\nlet abandonmentProbability = 0.1; // Initial probability\nconst penaltyCoefficient = 1.5;\n\nwhile (/* task not done */) {\n  // ... agent action ...\n  stepCounter++;\n\n  if (stepCounter > maxSteps) {\n    if (Math.random() < abandonmentProbability) {\n      console.log(\"Abandoning task (too many steps).\");\n      return \"Task Abandoned\";\n    }\n    abandonmentProbability = (penaltyCoefficient * abandonmentProbability) % 1;\n  }\n}\n```\n\n**3. Memory Storage and Sharing Mechanism:**\n\n* **Scenario:** A multi-agent shopping assistant. One agent recommends products, another manages the cart, and a third handles checkout.\n* **JavaScript Implementation:**\n    * Use a shared, in-memory database (e.g., Redis, or even a simple JavaScript object) accessible to all agents.\n    * Store agent actions, LLM outputs, user preferences, cart items, etc., in this shared memory.\n    * Use Handoff tools to facilitate communication and data transfer between agents:\n\n```javascript\n// Example: Handoff from product recommendation agent to cart agent\nsharedMemory.cart.items.push(recommendedProduct);\nsharedMemory.currentAgent = \"cartAgent\";\n```\n\n**4. MCP Compatibility (Not in detail but relevant for future integrations):**\n\n* **Benefit:** Standardizes communication between agents and external tools (APIs, databases).\n* **JavaScript Implementation:**  Develop a JavaScript library that conforms to the MCP specification, allowing easy integration with diverse tools and services.  This would require more detailed specifications about the MCP protocol.\n\n\n**JavaScript Frameworks and Libraries:**\n\n* **LangChain.js:** Interacting with LLMs, managing prompts, chains, and agents.\n* **Redis:** For implementing shared memory between agents.\n* **Socket.IO:**  For real-time communication between agents if needed.\n* **Custom modules:**  For implementing specific algorithms and logic outlined in the paper.\n\n\nBy incorporating these examples and leveraging appropriate JavaScript tools, developers can create more robust, adaptable, and efficient LLM-based multi-agent web applications. This paper provides a solid theoretical foundation to guide practical implementation and further experimentation.",
  "pseudocode": "```javascript\n// Algorithm 1: ReAct Based Action Strategy\n\nfunction reactActionStrategy(userRequest, trajectory, currentState, tools) {\n  // 1. Extract events related to userRequest from trajectory and currentState\n  const events = extractEvents(userRequest, trajectory, currentState);\n\n  // 2. Check if userRequest is completed based on events\n  if (isCompleted(userRequest, events)) {\n    return \"success\"; // Goal achieved\n  } else {\n    // 3. Analyze and extract remaining subtasks\n    const subtasks = extractSubtasks(userRequest, events);\n\n    // 4. Select relevant tools\n    const relevantTools = selectRelevantTools(subtasks, tools);\n\n\n    if (relevantTools.length > 0) {\n      // 5. Plan the next action\n      const nextAction = planNextAction(events, subtasks);\n\n      // 6. Select tool for executing nextAction\n      const selectedTool = selectTool(nextAction, relevantTools);\n\n      // 7. Generate arguments for selectedTool\n      const arguments = generateArguments(selectedTool, nextAction);\n\n      return { tool: selectedTool, args: arguments };\n    } else {\n      return \"failure\"; // No suitable tool found\n    }\n\n  }\n}\n\n\n\n\n// Helper functions (placeholders - needs actual implementation based on your LLM and application logic)\nfunction extractEvents(userRequest, trajectory, currentState) { /* ... */ }\nfunction isCompleted(userRequest, events) { /* ... */ }\nfunction extractSubtasks(userRequest, events) { /* ... */ }\nfunction selectRelevantTools(subtasks, tools) { /* ... */ }\nfunction planNextAction(events, subtasks) { /* ... */ }\nfunction selectTool(nextAction, relevantTools) { /* ... */ }\nfunction generateArguments(selectedTool, nextAction) { /* ... */ }\n\n\n// Algorithm 2: Timely Abandonment Strategy\nfunction timelyAbandonmentStrategy(userRequest, abandonmentProb, penaltyCoeff, stepEstimator, nextMoveEstimator, executor) {\n    let estimatedSteps = stepEstimator(userRequest);\n    let currentSteps = 0;\n    let p = abandonmentProb; \n\n    while (true) {\n        let nextMove = nextMoveEstimator(userRequest, /* ... other arguments if necessary ... */);\n        let result = executor(nextMove);\n\n        if (isCompleted(userRequest, result)) { // Assuming executor's result provides completion status\n            return \"success\";\n        } else if (isUnattainable(userRequest, result)) { // Assuming you have an isUnattainable function\n            return \"failure\";\n        }\n\n\n        if (currentSteps > estimatedSteps) {\n            let rand = Math.random(); // Random number between 0 and 1\n            if (rand > p) {\n                p = (penaltyCoeff * p) % 1;  // Update abandonment probability \n            } else {\n                return \"failure\"; // Abandon task\n            }\n        }\n\n        currentSteps++;\n    }\n}\n\n// Placeholder functions (These need implementation specific to your task and agent)\nfunction isCompleted(userRequest, result) {/* ... */}\nfunction isUnattainable(userRequest, result) {/* ... */}\n\n\n\n\n```\n\n**Algorithm 1: ReAct Based Action Strategy**\n\n* **Purpose:**  Dynamically determines an agent's next action based on the history of its interaction (trajectory), the current state, and the available tools. It mimics the ReAct (Reason + Act) pattern, which improves robustness and reduces hallucinations in LLMs by iteratively reasoning and acting upon the environment's feedback.\n\n* **Explanation:** The algorithm first checks if the task is complete based on the current trajectory and state. If not, it identifies the remaining subtasks, selects relevant tools, plans the next action using the LLM (thought engine), chooses the specific tool for that action, generates necessary arguments for the tool, and returns the tool and its arguments for execution. If no relevant tool is found, it signals failure.  The helper functions (like `extractEvents`, `isCompleted`, etc.) are placeholders and require concrete implementations tailored to the specific application and the LLM used.\n\n**Algorithm 2: Timely Abandonment Strategy**\n\n* **Purpose:**  Prevents agents from getting stuck in unproductive loops or wasting resources on tasks that are unlikely to succeed. It introduces a probabilistic mechanism for abandoning tasks when the number of execution steps exceeds an estimated threshold.\n\n* **Explanation:**  The algorithm first estimates the required steps for the task.  It then enters a loop, generating and executing actions. If the task is completed successfully or becomes unattainable, the loop terminates and the corresponding result is returned. The crucial part is the dynamic abandonment mechanism: if the number of current steps surpasses the estimated steps, the algorithm generates a random number. If this number is greater than the current abandonment probability (`p`), the task continues, but `p` is increased (penalized) based on the `penaltyCoeff`.  If the random number is less than `p`, the task is abandoned and failure is returned. This dynamic adjustment of `p` ensures that the longer a task runs beyond its estimated time, the higher the probability of it being abandoned, thus preventing resource wastage.  Again, the helper functions (`isCompleted`, `isUnattainable`, `stepEstimator`, `nextMoveEstimator`, and `executor`) are placeholders that need concrete implementation based on the specific use case.",
  "simpleQuestion": "How can I build robust, collaborative LLM agents?",
  "timestamp": "2025-04-08T05:03:21.398Z"
}