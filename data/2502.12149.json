{
  "arxivId": "2502.12149",
  "title": "HARBOR: Exploring Persona Dynamics in Multi-Agent Competition",
  "abstract": "We investigate factors contributing to LLM agents' success in competitive multi-agent environments, using auctions as a testbed where agents bid to maximize profit. The agents are equipped with bidding domain knowledge, distinct personas that reflect item preferences, and a memory of auction history. Our work extends the classic auction scenario by creating a realistic environment where multiple agents bid on houses, weighing aspects such as size, location, and budget to secure the most desirable homes at the lowest prices. Particularly, we investigate three key questions: (a) How does a persona influence an agent's behavior in a competitive setting? (b) Can an agent effectively profile its competitors' behavior during auctions? (c) How can persona profiling be leveraged to create an advantage using strategies such as theory of mind? Through a series of experiments, we analyze the behaviors of LLM agents and shed light on new findings. Our testbed, called HARBOR, offers a valuable platform for deepening our understanding of multi-agent workflows in competitive environments.",
  "summary": "This paper explores how LLMs behave in competitive multi-agent environments, specifically auctions, by giving them distinct \"personas\" (preferences and backstories).  The system, HARBOR, simulates house bidding and investigates how personas influence bidding strategies and outcomes (profit, item acquisition aligned with persona).  Key points for LLM-based multi-agent systems include: persona-driven agents deviate from purely profit-driven behavior, agents can profile each other's personas based on bidding behavior, Theory of Mind combined with strategic bidding improves agent performance, and second-order Theory of Mind, while helpful, needs expert strategies to be truly effective.  More agents competing makes profiling and persona-based strategy less reliable.",
  "takeaways": "This paper presents exciting opportunities for JavaScript developers working with LLM-based multi-agent systems. Here's how a developer can translate the insights from the HARBOR framework into practical web applications:\n\n**1. Persona-Driven Agents in E-commerce:**\n\n* **Scenario:** Imagine building a multi-agent chatbot system for an e-commerce platform.  Each agent represents a different product category (e.g., electronics, fashion, home goods). Each agent also has a distinct \"persona\" reflecting the typical customer for that category (e.g., tech-savvy for electronics, fashion-conscious for clothing).\n* **Implementation:**\n    * **LangChain:** Use LangChain's agent capabilities and chain functionalities. Define separate chains for each product agent, with prompts incorporating the specific persona (e.g., \"You are a knowledgeable and helpful electronics expert assisting a customer...\").\n    * **Persona Vectors:** Represent personas as vectors (as described in the paper). You could use a simple JavaScript array or object to hold the persona weights for each agent. This allows for quantifiable comparisons and updates.\n    * **Frontend Integration:** Integrate these agents into a frontend framework like React or Vue.js. Each chatbot window could represent an agent.  \n* **Benefit:** This allows agents to tailor recommendations and interactions to specific customer types, leading to a more personalized and effective shopping experience.\n\n**2. Multi-Agent Content Creation:**\n\n* **Scenario:**  Develop a system where multiple LLM agents collaborate to create different sections of a blog post or website copy. Each agent specializes in a particular writing style (e.g., technical, creative, persuasive).\n* **Implementation:**\n    * **Node.js with message passing:** Use Node.js to create a system where agents can communicate through message queues (e.g., RabbitMQ, Kafka).  Each agent, running its own LangChain chain, can contribute its part based on its persona and writing style.\n    * **Profiling:** Implement a basic profiling mechanism in JavaScript where agents analyze each otherâ€™s contributions to infer writing style. This could involve analyzing word usage, sentence structure, or sentiment.\n    * **Collaborative Editing:** Use a collaborative text editor library (e.g., ProseMirror, CKEditor) integrated into the frontend to visually represent the multi-agent collaboration.\n* **Benefit:** This facilitates a more diverse and dynamic content creation process, mimicking human collaboration.\n\n**3. Competitive Bidding Platforms:**\n\n* **Scenario:** Develop an online auction platform or a real-time bidding system for online advertising. Each agent represents a bidder, with different bidding strategies and budgets.\n* **Implementation:**\n    * **Serverless functions (AWS Lambda, Google Cloud Functions):** Use serverless functions to implement individual bidding agents. This allows for scalable and efficient handling of numerous concurrent bids.\n    * **ToM Simulation:** Experiment with basic Theory of Mind by having agents try to predict each other's bidding behavior based on past actions and available budget. This can be done through simple statistical models in JavaScript.\n    * **Data Visualization (D3.js, Chart.js):** Visualize the bidding dynamics and agent performance using JavaScript charting libraries to help understand the impact of personas and strategies.\n* **Benefit:** This allows for more realistic simulation of bidding behavior and provides insights into market dynamics.\n\n**4. Multi-Agent Gaming:**\n\n* **Scenario:** Create a web-based multiplayer game where each player is controlled by an LLM agent with a unique playing style (aggressive, defensive, strategic).\n* **Implementation:**\n    * **WebSockets:** Use WebSockets for real-time communication between agents and the game server.\n    * **Game Engine (Phaser, Babylon.js):** Use a JavaScript game engine to handle game logic and rendering.\n    * **Persona Injection:** Inject personas into agents by modifying their prompts (e.g., \"You are a highly competitive player who prioritizes winning above all else...\").\n* **Benefit:** This allows for more dynamic and engaging gameplay.\n\n**Key JavaScript libraries and frameworks:**\n\n* **LangChain:** for managing LLM interactions and agent functionalities.\n* **Node.js:** For backend logic and inter-agent communication.\n* **React, Vue.js:** For frontend development and user interface.\n* **RabbitMQ, Kafka:** For message queuing and distributed systems.\n* **ProseMirror, CKEditor:** For collaborative text editing.\n* **AWS Lambda, Google Cloud Functions:** For serverless computing.\n* **D3.js, Chart.js:** For data visualization.\n* **WebSockets:** For real-time communication.\n* **Phaser, Babylon.js:** For game development.\n\nBy combining these tools and the insights from the HARBOR paper, JavaScript developers can create innovative and powerful multi-agent web applications. Remember to start with simpler implementations, gradually adding complexity as you gain experience. This exciting field is rapidly evolving, and JavaScript developers are at the forefront of bringing multi-agent AI to the web.",
  "pseudocode": "```javascript\nfunction calculateProfit(trueValue, winningBid) {\n  return trueValue - winningBid;\n}\n\nfunction calculateMaxProfit(trueValue, startingPrice) {\n  return trueValue - startingPrice;\n}\n\nfunction calculateProfitRatio(itemsWon, trueValues, winningBids, allItems) {\n  let totalProfit = 0;\n  let maxPossibleProfit = 0;\n\n  for (const item of itemsWon) {\n    totalProfit += calculateProfit(trueValues[item], winningBids[item]);\n  }\n\n  for (const item of allItems) {\n    maxPossibleProfit += calculateMaxProfit(trueValues[item], allItems[item].startingPrice); // Assumes allItems object has startingPrice\n  }\n\n  return (totalProfit / maxPossibleProfit);\n\n}\n\nfunction calculateMatchedItemAcquisitionRate(itemsWon, personaAlignedItems) {\n  let matchedItemsCount = 0;\n\n  for (const item of itemsWon) {\n    if (personaAlignedItems.includes(item)) {\n      matchedItemsCount++;\n    }\n  }\n  return (matchedItemsCount / personaAlignedItems.length) ;\n}\n\nfunction updateProfilingVector(previousVector, currentItem, biddingHistory) {\n    // This function requires an LLM call, which is simulated here.\n    // In a real application, you'd integrate with a language model API.\n\n    // Simplified logic for demonstration:\n    const updatedVector = [...previousVector]; // Create a copy to avoid modifying the original\n    const bids = biddingHistory.filter(bid => bid.item === currentItem);\n\n\n    // Example logic: Increase preference if agent bid aggressively\n    if(bids.length > 3 && bids[bids.length -1].amount > currentItem.startingPrice*1.5 ) { \n        //Find a relevant persona index and increase preference: this would depend on how your personas are mapped to house features.\n        updatedVector[ relevantPersonaIndex] = Math.min(updatedVector[ relevantPersonaIndex] + 0.2, 1); //Increase and cap at 1\n    }\n    return updatedVector;\n}\n\n\nfunction updatePriorityList(budget, persona, items, status, profiles, previousList) {\n     // This function requires an LLM call.\n    // Simplified logic for demonstration:\n    const updatedList = {...previousList};\n    // Example logic: Increase priority if budget is high and item matches persona\n    for (const item in items){\n        if (budget > 700000 && persona.preferences.includes(item.type)){ // Example logic.\n            updatedList[item.name] = 3; //Highest Priority\n        }\n    }\n    return updatedList;\n\n}\n\n\n```\n\n\n**Explanations:**\n\n1. **`calculateProfit(trueValue, winningBid)`:** Calculates the profit for a single item by subtracting the winning bid from the item's true value.\n\n2. **`calculateMaxProfit(trueValue, startingPrice)`:** Calculates the maximum possible profit for a single item if won at the starting price.\n\n3. **`calculateProfitRatio(itemsWon, trueValues, winningBids, allItems)`:** Calculates the profit ratio (R) by dividing the agent's total profit by the maximum possible profit across all items in the auction.  Assumes `trueValues` and `winningBids` are keyed by item name. `allItems` is an object containing all the items in the auction, each with its name and starting price.\n\n\n4. **`calculateMatchedItemAcquisitionRate(itemsWon, personaAlignedItems)`:**  Calculates the matched item acquisition rate (A), indicating how many persona-aligned items the agent acquired.  `personaAlignedItems` is an array of the names of items that align with the agent's persona.\n\n\n5. **`updateProfilingVector(previousVector, currentItem, biddingHistory)`:** Updates a competitor's persona profiling vector based on their bidding behavior for a specific item. This is a simplified example, and a real implementation would require an LLM call to analyze the bidding history and infer persona weights. The example logic increases persona preference if the agent bids frequently and aggressively on a certain type of house.\n\n6. **`updatePriorityList(budget, persona, items, status, profiles, previousList)`:** Updates an agent's priority list (L) for remaining items based on their current budget, persona, available items, the status of other agents, competitor profiles, and their previous priority list. This function also necessitates an LLM call in a real implementation.  The example given shows simplistic logic to highlight how the different inputs would be used.\n\n\nThese JavaScript functions represent the core calculations and logic described in the paper.  Note that the `updateProfilingVector` and `updatePriorityList` functions are highly simplified because they require integration with a Large Language Model, which is beyond the scope of this pseudocode to javascript conversion. They provide a starting point for JavaScript developers to implement the concepts presented in the HARBOR framework.",
  "simpleQuestion": "How do personas affect LLM agent auction success?",
  "timestamp": "2025-02-18T06:05:09.240Z"
}