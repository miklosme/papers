{
  "arxivId": "2410.20143",
  "title": "Exploring Welfare Maximization and Fairness in Participatory Budgeting",
  "abstract": "Participatory budgeting (PB) is a voting paradigm for distributing a divisible resource, usually called a budget, among a set of projects by aggregating the preferences of individuals over these projects. It is implemented quite extensively for purposes such as government allocating funds to public projects and funding agencies selecting research proposals to support. This dissertation studies the welfare-related and fairness-related objectives for different PB models. Our contribution lies in proposing and exploring novel PB rules that maximize welfare and promote fairness, as well as, in introducing and investigating a range of novel utility notions, axiomatic properties, and fairness notions, effectively filling the gaps in the existing literature for each PB model. The thesis is divided into two main parts, the first focusing on dichotomous and the second focusing on ordinal preferences. Each part considers two cases: (i) the cost of each project is restricted to a single value and partial funding is not permitted and (ii) the cost of each project is flexible and may assume multiple values.",
  "summary": "This thesis explores how to fairly and efficiently distribute a budget across a set of projects based on people's preferences. It considers different ways people can express their preferences (simple approval, ranking, ranking with cost limits) and different constraints on project costs (fixed, flexible, partially flexible).  \n\nThe key points relevant to LLM-based multi-agent systems are the **characterizations of unanimous and strategy-proof random social choice rules**, particularly under the context of **single-peaked preferences**. The thesis proposes **novel fairness notions (weak-GEG and strong-GEG)** that are relevant to scenarios where voters are divided into groups, ensuring fair representation for each group. These characterizations and fairness notions can be valuable when designing multi-agent systems where LLMs need to make fair and strategic decisions based on potentially conflicting preferences of different agents or groups of agents.",
  "takeaways": "This paper delves deep into the theoretical foundations of **Participatory Budgeting (PB)**, a voting system for allocating resources. While it doesn't directly address LLM-based multi-agent systems or JavaScript, its insights on **welfare maximization and fairness** can be valuable for JavaScript developers working in this space. Let's bridge the gap with some practical examples:\n\n**Scenario: Collaborative Project Management Tool**\n\nImagine you're building a web app for managing projects where team members contribute ideas and vote on feature prioritization. This can be viewed as a PB problem.\n\n**Applying the Paper's Insights:**\n\n1. **Egalitarian Welfare Maximization (Chapter 3):**  The paper introduces the **Maxmin Participatory Budgeting (MPB)** rule to maximize the satisfaction of the least satisfied team member. You could implement this in your JavaScript app using a library like `Knapsack.js` to find the optimal set of features within the project's budget and time constraints while ensuring that no team member feels entirely left out.\n\n   ```javascript\n   import Knapsack from 'knapsack.js';\n\n   const features = [\n       { name: 'Feature A', cost: 5, votes: [1, 2, 3] }, \n       // ... other features with costs and voter approvals\n   ];\n   const budget = 15; \n\n   // Find the optimal feature set maximizing egalitarian welfare\n   const knapsack = new Knapsack();\n   const selectedFeatures = knapsack.solve(features, budget);\n   ```\n\n2. **Partially Flexible Costs (Chapter 4):**  The paper explores scenarios where features have multiple \"degrees of sophistication\" with varying costs. In your project management tool, this could translate to features having optional add-ons or levels of complexity.\n\n   * **User Interface:** You could use a JavaScript framework like React to create interactive components, allowing users to select different cost levels for each feature (e.g., sliders or dropdown menus).\n   * **Utility Functions:** Implement the different utility functions (cardinal, cost, cost capped, distance disutility) described in the paper to calculate user satisfaction based on chosen cost levels. This allows flexibility in how user preferences translate to project outcomes.\n\n3. **Fairness Under Ordinal Preferences (Chapters 5 & 6):**  Consider scenarios where users rank features in order of importance (ordinal preferences).\n\n   * **Single-Peaked Preferences:** If you believe user preferences tend to be single-peaked (e.g., most users agree on a general order of feature importance), you can use algorithms inspired by the paper's characterizations of fair rules. \n   * **Visualizing Fairness:**  Use a JavaScript charting library like D3.js to visualize the probability distribution of budget allocation across features, making the fairness of the outcome transparent to users. \n\n**Key Takeaways for JavaScript Developers**\n\n* **Think beyond basic voting:** This paper pushes you to go beyond simple majority voting. It introduces sophisticated concepts to maximize user satisfaction and ensure fairness, especially in resource-constrained scenarios.\n* **Translate theory to code:**  The paper's algorithms and characterizations can be translated into JavaScript code. Libraries for optimization (e.g., `ml-knapsack`) and data visualization (e.g., `Chart.js`, `D3.js`) can be your allies.\n* **Consider user preferences:** The paper emphasizes the importance of understanding different types of user preferences (dichotomous, ordinal, cardinal). Design your app's UI to capture these preferences effectively.\n\n**Inspiring Further Exploration**\n\nWhile the paper provides a strong theoretical basis, it opens doors for further exploration.  JavaScript developers can experiment with:\n\n* **Simulating PB scenarios:** Create interactive demos using JavaScript to let users experiment with different PB rules and fairness notions.\n* **Integrating LLMs:** Explore how LLMs can assist in preference elicitation, explaining fairness concepts to users, or even suggesting fair allocation strategies based on user inputs and project constraints.\n\nBy connecting the theoretical underpinnings of this paper to the practical world of JavaScript and web development, you can create more robust, fair, and user-centric multi-agent applications.",
  "pseudocode": "```javascript\nfunction multiKnapsackTranslation(N, P, c, b, preferences) {\n  // Initialize an empty approval vote array for each voter\n  const A = Array(N.length).fill(null).map(() => []);\n\n  // Iterate over each voter\n  for (let i = 0; i < N.length; i++) {\n    let j = 1;\n    // Add equivalence classes greedily until budget constraint is violated\n    while (c(A[i]) + c(preferences[i][j]) <= b) {\n      A[i] = A[i].concat(preferences[i][j]);\n      j++;\n    }\n    const O = [];\n    // Add remaining projects from the next equivalence class if affordable\n    for (const p of preferences[i][j]) {\n      if (c(p) < b - c(A[i])) {\n        O.push(p);\n      }\n    }\n    A[i] = A[i].concat(O);\n  }\n\n  // Return the dichotomous preference profile\n  return A;\n}\n\nfunction costWorthyTranslation(preferences, alpha) {\n  // Initialize an empty approval vote array for each voter\n  const A = Array(preferences.length).fill(null).map(() => []);\n\n  // Iterate over each voter\n  for (let i = 0; i < preferences.length; i++) {\n    // Iterate over each project\n    for (let j = 1; j <= preferences[i].length; j++) {\n      // Approve the project if its cost is within the worth function limit\n      if (c(preferences[i][j - 1]) <= alpha(preferences[i].indexOf(preferences[i][j - 1]) + 1)) {\n        A[i].push(preferences[i][j - 1]);\n      }\n    }\n  }\n  // Return the dichotomous preference profile\n  return A;\n}\n\nfunction argRule(N, P, c, b, preferences, k) {\n  // Iterate over possible share values in decreasing order\n  for (let theta = b; theta >= 1; theta--) {\n    // Find the minimum sum of ranks across all voters for the given share\n    let minSumOfRanks = Infinity;\n    let optimalSubsets = [];\n    for (const S of powerset(P)) {\n      if (c(S) <= b) {\n        let sumOfRanks = 0;\n        for (let i = 0; i < N.length; i++) {\n          sumOfRanks += ti(theta, S, preferences[i]);\n        }\n        if (sumOfRanks < minSumOfRanks) {\n          minSumOfRanks = sumOfRanks;\n          optimalSubsets = [S];\n        } else if (sumOfRanks === minSumOfRanks) {\n          optimalSubsets.push(S);\n        }\n      }\n    }\n\n    // Check if the average rank is within the limit\n    if (minSumOfRanks <= k * N.length) {\n      // Return all optimal subsets for the maximum possible share value\n      return optimalSubsets;\n    }\n  }\n}\n```\n\n**Algorithm 5.1: Multi-knapsack translation scheme**\n\nThis algorithm translates incomplete weakly ordinal preferences into dichotomous preferences by applying a greedy knapsack approach for each voter. It considers each voter's preference ranking and iteratively adds projects from each equivalence class to their approval vote until the budget constraint is violated. Then, it selectively adds affordable projects from the next equivalence class to maximize the voter's satisfaction within the budget limit.\n\n**Algorithm 5.2: Cost-worthy translation scheme**\n\nThis algorithm translates incomplete weakly ordinal preferences into dichotomous preferences based on a \"worth function\" that determines the maximum amount a project at a specific rank deserves. It ensures that only projects deemed cost-worthy by the organizer based on their rank and cost are approved by each voter.\n\n**Algorithm 5.3: ARG rule**\n\nThis algorithm implements the Average Rank Guarantee (ARG) rule, aiming to allocate a share of the budget fairly among projects favored by each voter. It takes a rank parameter 'k' as input, indicating the top 'k' ranks considered satisfactory for a voter. The algorithm iteratively searches for the maximum possible share value that can be guaranteed within the top 'k' ranks for all voters on average. It then returns all feasible subsets of projects that achieve this maximum share guarantee.",
  "simpleQuestion": "How can we make participatory budgeting fair and efficient?",
  "timestamp": "2024-10-29T06:06:16.431Z"
}